<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>
PRISM Manual | Main / AllOnOnePage 
</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords" content="prism, probabilistic, symbolic, model, checker, verification, birmingham, oxford, parker, norman, kwiatkowska">

<link rel="icon" href="../pub/skins/offline/images/p16.ico" type="image/x-icon">
<link rel="shortcut icon" href="../pub/skins/offline/images/p16.ico" type="image/x-icon">

<!--HTMLHeader--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.sourceblocklink {
  text-align: right;
  font-size: smaller;
}
.sourceblocktext {
  padding: 0.5em;
  border: 1px solid #808080;
  background-color: #F1F0ED;
}
.sourceblocktext div {
  font-family: monospace;
  font-size: small;
  line-height: 1.0;
  height: 1%;
}
.sourceblocktext div.head,
.sourceblocktext div.foot {
  font: italic medium serif;
  padding: 0.5em;
}
.codeblocklink {
  text-align: right;
  font-size: smaller;
}
.codeblocktext {
  text-align: left;
  padding: 0.5em;
  border: 1px solid #808080;
  background-color: #F1F0ED;
}
.codeblocktext pre {
  font-family: monospace;
  font-size: small;
  line-height: 1.0;
}.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }
/* GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter) */
.xml  {font-family: monospace;}
.xml .imp {font-weight: bold; color: red;}
.xml .coMULTI {color: #808080; font-style: italic;}
.xml .es0 {color: #000099; font-weight: bold;}
.xml .br0 {color: #66cc66;}
.xml .st0 {color: #ff0000;}
.xml .nu0 {color: #cc66cc;}
.xml .sc0 {color: #00bbdd;}
.xml .sc1 {color: #ddbb00;}
.xml .sc2 {color: #339933;}
.xml .sc3 {color: #009900;}
.xml .re0 {color: #000066;}
.xml .re1 {font-weight: bold; color: black;}
.xml .re2 {font-weight: bold; color: black;}
/* GeSHi (C) 2004 - 2007 Nigel McNie (http://qbnz.com/highlighter) */
.bash  {font-family: monospace;}
.bash .imp {font-weight: bold; color: red;}
.bash .kw1 {color: #b1b100;}
.bash .kw3 {color: #000066;}
.bash .es0 {color: #000099; font-weight: bold;}
.bash .br0 {color: #66cc66;}
.bash .st0 {color: #ff0000;}
.bash .nu0 {color: #cc66cc;}
.bash .re0 {color: #0000ff;}
.bash .re1 {color: #0000ff;}
.bash .re2 {color: #0000ff;}
.bash .re3 {color: #808080; font-style: italic;}
.bash .re4 {color: #0000ff;}

--></style>  <meta name='robots' content='index,follow' />


<link type="text/css" rel="stylesheet" href="../pub/skins/offline/css/base.css">
<link type="text/css" rel="stylesheet" href="../pub/skins/offline/css/prism.css">
<link type="text/css" rel="stylesheet" href="../pub/skins/offline/css/prismmanual.css">

</head>

<body text="#000000" bgcolor="#ffffff">

<div id="layout-maincontainer">
<div id="layout-main">

<div id="prism-mainbox">

<!-- ============================================================================= -->

<!--PageHeaderFmt-->
<!--/PageHeaderFmt-->

<!--PageTitleFmt--><!--PageText-->
<div id='wikitext'>
<div class='vspace'></div><h1><span class='big'>PRISM Manual</span> &nbsp; version 3.3.1</h1>
<hr />
<h1><span class='big'>Contents</span></h1>
<hr />
<h1><a class='wikilink' href='Introduction.html'>Introduction</a></h1>
<div class='vspace'></div><h1><a class='wikilink' href='../InstallingPRISM/Instructions.html'>Installing PRISM</a></h1>
<ul><li><a class='wikilink' href='../InstallingPRISM/Instructions.html'>Instructions</a>
</li><li><a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>
</li></ul><div class='vspace'></div><h1><a class='wikilink' href='../ThePRISMLanguage/Introduction.html'>The PRISM Language</a></h1>
<ul><li><a class='wikilink' href='../ThePRISMLanguage/Introduction.html'>Introduction</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Example1.html'>Example 1</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/ModelType.html'>Model Type</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/ModulesAndVariables.html'>Modules And Variables</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/InitialStates.html'>Initial States</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Commands.html'>Commands</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/ParallelComposition.html'>Parallel Composition</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/LocalNondeterminism.html'>Local Nondeterminism</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/ModuleRenaming.html'>Module Renaming</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Example2.html'>Example 2</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Constants.html'>Constants</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Expressions.html'>Expressions</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Synchronisation.html'>Synchronisation</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/ProcessAlgebraOperators.html'>Process Algebra Operators</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/GlobalVariables.html'>Global Variables</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/FormulasAndLabels.html'>Formulas And Labels</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/PRISMLanguageFiles.html'>PRISM Language Files</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/CostsAndRewards.html'>Costs And Rewards</a>
</li></ul><div class='vspace'></div><h1><a class='wikilink' href='../PropertySpecification/Introduction.html'>Property Specification</a></h1>
<ul><li><a class='wikilink' href='../PropertySpecification/Introduction.html'>Introduction</a>
</li><li><a class='wikilink' href='../PropertySpecification/IdentifyingASetOfStates.html'>Identifying A Set Of States</a>
</li><li><a class='wikilink' href='../PropertySpecification/ThePOperator.html'>The P Operator</a>
</li><li><a class='wikilink' href='../PropertySpecification/QuantitativeProperties.html'>Quantitative Properties</a>
</li><li><a class='wikilink' href='../PropertySpecification/TheSOperator.html'>The S Operator</a>
</li><li><a class='wikilink' href='../PropertySpecification/Reward-basedProperties.html'>Reward-based Properties</a>
</li><li><a class='wikilink' href='../PropertySpecification/SyntaxAndSemantics.html'>Syntax And Semantics</a>
</li><li><a class='wikilink' href='../PropertySpecification/PropertiesFiles.html'>Properties Files</a>
</li></ul><div class='vspace'></div><h1><a class='wikilink' href='../RunningPRISM/StartingPRISM.html'>Running PRISM</a></h1>
<ul><li><a class='wikilink' href='../RunningPRISM/StartingPRISM.html'>Starting PRISM</a>
</li><li><a class='wikilink' href='../RunningPRISM/LoadingAndBuildingAModel.html'>Loading And Building a Model</a>
</li><li><a class='wikilink' href='../RunningPRISM/DebuggingModelsWithTheSimulator.html'>Debugging Models With The Simulator</a>
</li><li><a class='wikilink' href='../RunningPRISM/ExportingTheModel.html'>Exporting The Model</a>
</li><li><a class='wikilink' href='../RunningPRISM/ModelChecking.html'>Model Checking</a>
</li><li><a class='wikilink' href='../RunningPRISM/ApproximateComputationOfQuantitativeProperties.html'>Approximate Computation Of Quantitative Properties</a>
</li><li><a class='wikilink' href='../RunningPRISM/ComputingSteady-stateAndTransientProbabilities.html'>Computing Steady-state And Transient Probabilities</a>
</li><li><a class='wikilink' href='../RunningPRISM/Experiments.html'>Experiments</a>
</li><li><a class='wikilink' href='../RunningPRISM/SupportForPEPAModels.html'>Support For PEPA Models</a>
</li><li><a class='wikilink' href='../RunningPRISM/SupportForSBML.html'>Support For SBML</a>
</li><li><a class='wikilink' href='../RunningPRISM/ExplicitModelImport.html'>Explicit Model Import</a>
</li></ul><div class='vspace'></div><h1><a class='wikilink' href='../ConfiguringPRISM/Introduction.html'>Configuring PRISM</a></h1>
<ul><li><a class='wikilink' href='../ConfiguringPRISM/Introduction.html'>Introduction</a>
</li><li><a class='wikilink' href='../ConfiguringPRISM/ComputationEngines.html'>Computation Engines</a>
</li><li><a class='wikilink' href='../ConfiguringPRISM/IterativeNumericalMethods.html'>Iterative Numerical Methods</a>
</li><li><a class='wikilink' href='../ConfiguringPRISM/OtherOptions.html'>Other Options</a>
</li></ul><div class='vspace'></div><h1><a class='wikilink' href='References.html'>References</a></h1>
<p><br /><br />
</p><hr />
<h1><span class='big'>Introduction</span></h1>
<hr />
<p>PRISM is a <em>probabilistic model checker</em>,
a tool for the modelling and analysis of systems which exhibit probabilistic behaviour.
Probabilistic model checking is a <em>formal verification</em> technique.
It is based on the construction of a precise mathematical model of a system which is to be analysed.
Properties of this system are then expressed formally in temporal logic
and automatically analysed against the constructed model.
</p>
<p class='vspace'>PRISM has direct support for three types of probabilistic models:
</p>
<div class='vspace'></div><ul><li>discrete-time Markov chains (DTMCs),
</li><li>Markov decision processes (MDPs),
</li><li>continuous-time Markov chains (CTMCs).
</li></ul><p class='vspace'>Models are supplied to the tool by writing descriptions in the <a class='wikilink' href='../ThePRISMLanguage/Introduction.html'>PRISM language</a>, a simple, high-level modelling language.
</p>
<p class='vspace'>Properties of these models are written in the PRISM <a class='wikilink' href='../PropertySpecification/Introduction.html'>property specification language</a> which is based on temporal logic. It incorporates several well-known probabilistic temporal logics:
</p>
<div class='vspace'></div><ul><li>PCTL (probabilistic computation tree logic),
</li><li>CSL (continuous stochastic logic),
</li><li>LTL (linear time logic),
</li><li>PCTL* (which subsumes both PCTL and LTL).
</li></ul><p class='vspace'>plus support for <a class='wikilink' href='../PropertySpecification/Reward-basedProperties.html'>costs/rewards</a> and several other custom features and extensions.
</p>
<p class='vspace'>PRISM performs probabilistic model checking to automatically analyse such properties. It also contains a <a class='wikilink' href='../RunningPRISM/ApproximateComputationOfQuantitativeProperties.html'>discrete-event simulation</a> engine for approximate verification.
<br /><br />
</p><hr />
<div class='vspace'></div><h1><span class='big'>Installing PRISM</span></h1>
<hr />
<h1>Instructions</h1>
<h3>Prerequisites</h3>
<p>PRISM is known to run on Linux, Windows, Mac OS X and Solaris, including 64-bit variants of several of these operating systems.
</p>
<p class='vspace'>You will need Java, more specifically <a class='urllink' href='http://java.sun.com/javase/downloads/'>Sun's distribution of Java</a>. To run binary versions of PRISM, you only need the Java Runtime Environment (JRE), not the full Java Development Kit (JDK). Binaries are currently built using Java 6. If you are compiling from source, version 5.0 (sometimes also called version 1.5) or above is sufficient. If you don't know what version of Java you have, type <code>java -version</code> from a command prompt.
</p>
<p class='vspace'>To compile PRISM from source, you need the Java Development Kit (JDK), GNU make and a C/C++ compiler (e.g. gcc/g++). For compilation under Windows, you will need Cygwin. See below for more information.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Installation on Windows</h3>
<p>To install the latest versions of PRISM on Windows, just run the self-extracting installer which you <a class='urllink' href='http://www.prismmodelchecker.org/download.php'>downloaded</a>. For older versions (3.0 and earlier) you need to unpack the zip file by hand. In either case, you do <strong>not</strong> need administrator privileges to install PRISM - you just need to have write access to the directory in which you plan to install it.
</p>
<p class='vspace'>If requested, the installer will place shortcuts to run PRISM on the desktop and/or start menu. If not, you can run by PRISM double-clicking the file <code>xprism.bat</code> (which may just appear as <code>xprism</code>) in the <code>bin</code> folder of your PRISM folder. If nothing happens, the most likely explanation is that Java is not installed or not in your path. To check, open a command prompt window, navigate to the PRISM directory, type <code>cd bin</code>, then <code>xprism.bat</code> and examine the resulting error.
</p>
<p class='vspace'>If you want to create shortcuts to <code>xprism.bat</code> manually, you will find some PRISM icons in the <code>etc</code> folder. It is also best to change the "Run" option in the shortcut properties window from "Normal window" to "Minimized".
</p>
<p class='vspace'>If you wish to use the command-line version of PRISM on Windows, open a command prompt window and type for example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">cd "c:\Program Files\prism-3.0.beta1-win\bin"</span><br/>
<span style="font-weight:bold;">prism ..\examples\dice\dice.pm</span><br/>
</div></div>
</div>    
<p class='vspace'>You can also edit the file <code>bin\prism.bat</code> to allow it to be run from any location. See the instructions within the file for further details.
</p>
<p class='vspace'>PRISM is also known to run on 64-bit versions of Windows. Since we currently only provide 32-bit binary versions, this will only work if you are also running a 32-bit version of Java. If this is not possible for some reason, you will have to build PRISM from source using Cygwin (See below).
</p>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Installation of (non-Windows) binary versions</h3>
<p>To ensure compatibility, we recommend that you compile PRISM from source on non-Windows platforms. See below for instructions. However, we do <a class='urllink' href='http://www.prismmodelchecker.org/download.php'>provide</a> pre-compiled binary distributions for Linux (32-bit) and, depending on availability, other operating systems such as Mac OS X and Solaris.
</p>
<p class='vspace'>To install a binary distribution, unpack the tarred/zipped PRISM distribution into a suitable location, enter the directory and run the <code>install.sh</code> script, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">gunzip prism-3.2-linux.tar.gz</span><br/>
<span style="font-weight:bold;">tar xf prism-3.2-linux.tar</span><br/>
<span style="font-weight:bold;">cd prism-3.2-linux</span><br/>
<span style="font-weight:bold;">./install.sh</span><br/>
</div></div>
</div>
<p class='vspace'>You do not need to be root to install PRISM. The install script simply makes some small customisations to the scripts used to launch PRISM. The PRISM distribution is self-contained and can be freely moved/renamed, however if you do so you will need to re-run <code>./install.sh</code> afterwards.
</p>
<p class='vspace'>To run PRISM, execute either the <code>xprism</code> or <code>prism</code> script (for the graphical user interface or command-line version, respectively). These can be found in the <code>bin</code> directory. These scripts are designed to be run from anywhere and you can easily create symbolic links or aliases to them. If you want icons to create desktop shortcuts to PRISM, you can find some in the <code>etc</code> directory.
</p>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Building PRISM from source</h3>
<p>To compile PRISM form source code, you will need:
</p>
<div class='vspace'></div><ul><li>GNU make (sometimes called gmake)
</li><li>a C/C++ compiler (e.g. gcc/g++)
</li><li>Sun's <a class='urllink' href='http://java.sun.com/javase/downloads/'>Java Development Kit</a> (JDK), version 5.0 (sometimes called 1.5) or higher
</li></ul><p class='vspace'>To check what version of Java you have, type <code>java -version</code>. To check that you have the development kit, type <code>javac</code>. If you get an error message that <code>javac</code> cannot be found, you probably do not have the JDK installed (or your path is not set up correctly).
</p>
<p class='vspace'>Hopefully, you can build PRISM simply by entering the PRISM directory and running <code>make</code>, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">gunzip prism-3.2-src.tar.gz</span><br/>
<span style="font-weight:bold;">tar xf prism-3.2-src.tar</span><br/>
<span style="font-weight:bold;">cd prism-3.2-src</span><br/>
<span style="font-weight:bold;">make</span><br/>
</div></div>
</div>
<p class='vspace'>For this process to complete correctly, PRISM needs to be able to determine both the operating system you are using and the location of your Java distribution. If there is a problem with either of these, you will see an error message and will need to specify one or both of these manually, such as in these examples:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">make OSTYPE=linux</span><br/>
<span style="font-weight:bold;">make JAVA_DIR=/usr/java/jdk1.5.0</span><br/>
<span style="font-weight:bold;">make OSTYPE=cygwin JAVA_DIR="/cygdrive/c/Program Files/Java/jdk1.5.0"</span><br/>
</div></div>
</div>
<p class='vspace'>Note the use of double quotes for the case where the directory contains a space. If you don't know the location of your Java installation, try typing <code>which javac</code>. If the result is e.g. <code>/usr/java/jdk1.5.0/bin/javac</code> then your Java directory is <code>/usr/java/jdk1.5.0</code>. Sometimes <code>javac</code> will be a symbolic link, in which case use "<code>ls -l</code>" to determine the actual location.
</p>
<p class='vspace'>It is also possible to to set the environment variables <code>OSTYPE</code> and <code>JAVA_DIR</code> directly or edit their values in the Makefile directly. Note that even when you specify <code>JAVA_DIR</code> explicitly (in either way), PRISM still uses the versions of <code>javac</code> (and <code>javah</code>) that are in your path so make sure this is set up correctly.
</p>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Building PRISM on 64-bit machines</h3>
<p>PRISM has also been successfully compiled under Linux on a variety of 64-bit architectures. In general this should work exactly as described above. The Makefile will try to detect that you are compiling on a 64-bit machine but, if this does not work for some reason, you can override detection by setting <code>ARCH</code> to either <code>amd64</code> (for AMD/Intel 64) or <code>ia64</code> (for Itanium). For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">make ARCH=amd64</span><br/>
</div></div>
</div>
<p class='vspace'>For 64-bit Macs, see below.
</p>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Building PRISM on Macs</h3>
<p>In most cases, you should be able to build PRISM from source under Mac OS X using the instructions given above. There are, however, a few known issues to be aware of.
</p>
<p class='vspace'>The most common problem is when building on recent 64-bit Macs, under which PRISM has some issues with Java. The best advice, currently, is to compile and run a 32-bit version of PRISM. To do this:
</p>
<div class='vspace'></div><ol><li>Make sure you are using a 32-bit version of Java (e.g. through "Java Preferences" under /Applications/Utilities).
<div class='vspace'></div></li><li>Make sure you have the very latest version of PRISM <a class='urllink' href='http://www.prismmodelchecker.org/download.php'>available</a> (for version 3.3, get the final release, not beta1 or beta2).
<div class='vspace'></div></li><li>Build PRISM (as above).
</li></ol><p class='vspace'>If this still does not work, it may be that PRISM is detecting automatically that you are on a 64-bit machine. You can override this as follows:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">make clean_all</span><br/>
<span style="font-weight:bold;">make ARCH=</span><br/>
</div></div>
</div>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Building PRISM from source on Windows using Cygwin</h3>
<p>The compilation of PRISM currently relies on a Unix-like environment. On Windows, this can be achieved using the <a class='urllink' href='http://www.cygwin.com/'>Cygwin</a> development environment (or alternatively using <a class='urllink' href='http://www.mingw.org/'>MSYS</a>). Once Cygwin is installed, you can proceed as described in the previous section. Note that the PRISM compilation process uses the <a class='urllink' href='http://www.mingw.org/'>MinGW</a> libraries so that the final result is independent of Cygwin at run-time.
</p>
<p class='vspace'>One thing to note: please unzip the PRISM distribution from within Cygwin (e.g. using <code>tar xfz prism-XXX-src.tar.gz</code>). Don't use a Windows program (Winzip, etc.) since this can cause problems.
</p>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Building PRISM from source on Windows using MSYS</h3>
<p>Compiling from source in <a class='urllink' href='http://www.mingw.org/'>MSYS</a> is less obvious as this environment is currently not directly supported in the makefile. Additionally, MSYS does not handle symlinks in the same way as cygwin does. The first problem is fixed by providing a OSTYPE variable to the makefile, whereas the second problem currently has to be solved manually.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">make OSTYPE=cygwin</span><br/>
</div></div>
</div>
<p class='vspace'>At some point it will fail, saying that it cannot find the CUDD library, this is due to the failing symlinks. We can solve this by means of a few commands: 
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">cd cudd/</span><br/>
<span style="font-weight:bold;">rmdir lib/ </span><br/>
<span style="font-weight:bold;">./setup.sh</span><br/>
<span style="font-weight:bold;">cd ..</span><br/>
<span style="font-weight:bold;">make OSTYPE=cygwin </span><br/>
<span style="font-weight:bold;">./install.sh</span><br/>
</div></div>
</div>
<p class='vspace'><strong>Problems?</strong> See the section "<a class='wikilink' href='../InstallingPRISM/CommonProblemsAndQuestions.html'>Common Problems And Questions</a>''.
</p><hr />
<h1>Common Problems And Questions</h1>
<p>This section describes some of the most common problems and questions related to the installation and running of PRISM. These are grouped into the following categories:
</p>
<div class='vspace'></div><ul><li>Running PRISM on Windows
</li><li>Running PRISM on non-Windows platforms
</li><li>Compiling PRISM
</li><li>Other issues
</li></ul><div class='vspace'></div><hr />
<div class='vspace'></div><h2>Running PRISM on Windows</h2>
<p><strong>When I try to run PRISM on Windows, I double-click the PRISM shortcut but nothing happens.</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>The most common cause of this is that you either do not have Java installed or the <code>java</code> executable is not in your path. In any case, to determine the exact problem, launch a command shell and navigate to the <code>bin</code> directory inside the directory where you installed PRISM (on recent versions the "PRISM (console)" shortcut installed in the start menu does this for you). Then, type <code>xprism.bat</code> and see what error message is displayed.
</p></div>
<div class='vspace'></div><hr />
<div class='vspace'></div><h2>Running PRISM on non-Windows platforms</h2>
<p><strong>When I try to run PRISM, I get an error of the form:<br /><code>Exception in thread "main" java.lang.NoClassDefFoundError: ...</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Check:
</p><ul><li>Did you run <code>install.sh</code> from the PRISM directory? (non-Windows platforms)
</li><li>If you compiled PRISM from source code, are you sure no errors occurred during the process? To check, go into the PRISM directory, type <code>make clean_all</code> and then re-compile, checking the output (especially at the end) carefully for any error messages.
</li></ul></div>
<p class='vspace'><strong>When I try to run PRISM, I get an error of the form:<br /><code>java.lang.UnsatisfiedLinkError: no prism in java.library.path</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Check:
</p><ul><li>Did you run <code>install.sh</code> from the PRISM directory? (non-Windows platforms)
</li><li>If you compiled PRISM from source code, are you sure no errors occurred during the process? To check, go into the PRISM directory, type <code>make clean_all</code> and then re-compile, checking the output (especially at the end) carefully for any error messages.
</li></ul><p class='vspace'>Are you on a 64-bit machine? If so, make sure that you are running 64-bit versions of <code>java</code> and <code>javac</code>. (Look for "<code>64-Bit Server VM</code>" in the output of <code>java -version</code>).
</p></div>
<p class='vspace'><strong>When I try to run PRISM, I get an error of the form:<br /><code>Exception in thread "main" java.lang.UnsupportedClassVersionError: Bad version number in .class file</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Your version of Java is too old. Install a newer version of Sun Java and then try again.
</p></div>
<p class='vspace'><strong>When I try to run a (Linux) binary version of PRISM, I get an error saying that <code>libstdc++.so.5 cannot be found</code> or <code>libstdc++.so.6 cannot be found</code>.</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>This is usually due to a discrepancy between the version of Linux that was used to build the binary distribution and the version that you are using to run it.
</p>
<p class='vspace'>If the error message is about <code>libstdc++.so.5</code>, you will just need to install an old version of the <code>libstdc++</code> library. This should be quite easy to find for most Linux distributions. On Fedora Core, for example, just type: <code>yum install compat-libstdc++-33</code> as root.
</p>
<p class='vspace'>If the error message is about <code>libstdc++.so.6</code>, you are running an older version of Linux than the binary release was compiled for. The easiest solution is to compile PRISM yourself from the source code version instead.
</p></div>
<p class='vspace'><strong>When I try to run PRISM, I get an error of the form:<br /><code>Exception in thread "main" java.lang.ExceptionInInitializerError<br />   at java.lang.Class.initializeClass(libgcj.so.7)<br />   at prism.PrismSettings.&lt;init&gt;(PrismSettings.java:297)</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>You are not running the <a class='urllink' href='http://java.sun.com/downloads/'>Sun</a> version of Java. You will need to install it.
</p></div>
<p class='vspace'><strong>When I try to run PRISM, I get an error of the form:<br /><code>java.lang.UnsatisfiedLinkError: libprism: ... cannot restore segment prot after reloc: Permission denied</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>This is likely to be caused by the default settings of <a class='urllink' href='http://www.nsa.gov/selinux/'>SELinux</a> on newer versions of Linux. Open up the "Security Level Configuration" (on Fedora, for example, this is found under "Administration | Security Level and Firewall" under the main menu or by running <code>system-config-securitylevel</code>). Look in the "Compatibility" section of the SELinux Policy settings and make sure "Allow the use of shared libraries with Text Relocation" is ticked. You may need to reboot for changes to take effect.
</p></div>
<p class='vspace'><strong>Do I have to use Sun's version of Java to build/run PRISM?</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Currently, this seems to be the case. We will aim to address this in the future.
</p></div>
<div class='vspace'></div><hr />
<div class='vspace'></div><h2>Compiling PRISM</h2>
<p><strong>I can't compile PRISM on Fedora 9. Why not?</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>This is because Fedora 9 comes with GCC 4.3 by default, which causes some problems. The easiest fix is to first install an older version of GCC (<code>yum install compat-gcc-34 compat-gcc-34-c++</code>) and then recompile using this version (<code>cd prism; make clean; make CPP=g++34</code>).
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, <code>make</code> seems to get stuck in an infinite loop</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>This is probably due to the detection of Java failing. Specify the location of your Java directory by hand, e.g. <code>make JAVA_DIR=/usr/java/jdk1.5.0</code>. See the <a class='wikilink' href='../InstallingPRISM/Instructions.html'>Instructions</a> page for more on this.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, I get errors of the form:<br /><code>/usr/bin/libtool: for architecture: cputype (16777234) cpusubtype (0) file: -lSystem is not an object file (not allowed in a library)</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Are you compiling PRISM on Max OS X? If so, the likely explanation is that you have upgraded to a new version of Mac OS X but have not upgraded the developer tools (eg. XCode). Upgrade and try again.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, nothing seems to happen</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Perhaps you are not using the GNU version of <code>make</code>. Try typing <code>make -v</code> to find out. On some systems, GNU make is called <code>gmake</code>.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, I get errors of the form:<br /><code>Unexpected end of line seen...</code><br />or:<br /><code>make: Fatal error in reader: Makefile, line 58: Unexpected end of line seen...</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Perhaps you are not using the GNU version of <code>make</code>. Try typing <code>make -v</code> to find out. On some systems, GNU make is called <code>gmake</code>.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, I get an error of the form:<br /><code>./setup.sh: line 33: syntax error: unexpected end of file</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Are you building on Cygwin? And did you unpack PRISM using WinZip? If so, unpack from Cygwin, using <code>tar xfz</code> (or similar) instead.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, I get an error of the form:<br /><code>Assembler messages:  Fatal error: can't create ../../obj/dd/dd_abstr.o: No such file or directory</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Did you unpack PRISM using a graphical tool or file manager? If so, unpack using <code>tar xfz</code> (or similar) instead.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, I get errors of the form:<br /><code>dirname: extra operand `Files/Java/jdk1.5.0_09/bin/javac' Try `dirname --help' for more information.</code></strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>This error occurs if the path to your Java distribution contains a space (a common example is when it is somewhere in "<code>Program Files</code>" on Windows). Hopefully, this will be fixed soon. A workaround is to move the java installation to e.g. <code>C:\java</code>.
</p></div>
<p class='vspace'><strong>When I try to compile PRISM, I get an error of the form:<br /><code>/bin/sh: line 43: [: :/cygdrive/c/Program: binary operator expected</code>...</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>See answer to previous question.
</p></div>
<p class='vspace'><strong>Do I have to use GNU <code>make</code> to build PRISM?</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Strictly speaking, no, but you will have to modify the various PRISM Makefiles manually to overcome this.
</p></div>
<p class='vspace'><strong>Can I build PRISM on operating systems other than those currently supported?</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>PRISM should be suitable for any Unix/Linux variant.
</p>
<p class='vspace'>The first thing you will need to do is compile CUDD (the BDD library used by and included in PRISM) on that platform.
Fortunately, CUDD has already been successfully built on a large number of
operating systems. Have a look at the sample Makefiles we provide (i.e. the
files <code>cudd/Makefile.*</code>) which are slight variants of the original Makefile
provided with CUDD (found here: <code>cudd/modified/orig/Makefile</code>). They contain
instructions on how to modify it for various platforms. You can then call
your new modified makefile something appropriate (<code>cudd/Makefile.$OSTYPE</code>) and
proceed to build PRISM as usual. To just build CUDD, not PRISM, type
<code>make cuddpackage</code> instead of <code>make</code>.
</p>
<p class='vspace'>Next, look at the main PRISM Makefile, in particular, each place where the
variable <code>$OSTYPE</code> is referred to. Most lines include comments and further
instructions. Once you have done this, proceed as usual.
</p>
<p class='vspace'>If you do successfully build PRISM on other platforms, please let us know
so we can include this information in future releases. Thanks.
</p></div>
<div class='vspace'></div><hr />
<div class='vspace'></div><h2>Other issues</h2>
<p><strong>How do I uninstall PRISM?</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>If you installed PRISM on Windows using the self-extracting installer, you can uninstall it using the option on the start menu. If you didn't add these shortcuts, just run <code>uninstall.exe</code> from the directory where you installed PRISM.
</p>
<p class='vspace'>For older versions of PRISM on Windows or on any other platform, simply delete the directory containing it.
</p>
<p class='vspace'>The only thing that is not removed via either of these methods is the <code>.prism</code> file containing your PRISM settings which is in your home directory (see the section "<a class='wikilink' href='../ConfiguringPRISM/Introduction.html'>Configuring PRISM</a>"). You may wish to retain this when upgrading.
</p></div>
<p class='vspace'><strong>I still have a problem installing/running PRISM. What can I do?</strong>
</p>
<div class='vspace'></div><div class='answer' > 
<p>Please post a message in the discussion group (see the <a class='urllink' href='http://www.prismmodelchecker.org/support.php'>support</a> section of the PRISM website).
</p></div>
<p><br /><br />
</p><hr />
<div class='vspace'></div><h1><span class='big'>The PRISM Language</span></h1>
<hr />
<h1>Introduction</h1>
<p>In order to construct and analyse a model with PRISM,
it must be specified in the PRISM language,
a simple, state-based language,
based on the Reactive Modules formalism of Alur and Henzinger [<a class='wikilink' href='References.html#AH99'>AH99</a>].
In this section, we describe the PRISM language and present a number of small illustrative examples.
A precise definition of the semantics of the language is available from the "<a class='urllink' href='http://www.prismmodelchecker.org/doc/'>Documentation</a>" section of the PRISM web site. One of the best ways to learn what can be done with the PRISM language is to look at some existing examples.
A number of these are included with the tool distribution in the <code>examples</code> directory.
Many additional examples can be found on the "<a class='urllink' href='http://www.prismmodelchecker.org/casestudies/'>Case Studies</a>" section of the <a class='urllink' href='http://www.prismmodelchecker.org/'>PRISM website</a>.
</p>
<p class='vspace'>The fundamental components of the PRISM language are <em>modules</em> and <em>variables</em>.
A model is composed of a number of <em>modules</em> which can interact with each other.
A module contains a number of local <em>variables</em>.
The values of these variables at any given time constitute the state of the module.
The <em>global state</em> of the whole model is determined by the <em>local state</em> of all modules.
The behaviour of each module is described by a set of <em>commands</em>.
A command takes the form:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">guard</span> -&gt; <span class="prismident">prob_1</span> : <span class="prismident">update_1</span> + ... + <span class="prismident">prob_n</span> : <span class="prismident">update_n</span>;<br/>
</div></div>
</div>
<p class='vspace'>The <em>guard</em> is a predicate over all the variables in the model (including those belonging to other modules). Each <em>update</em> describes a transition which the module can make if the guard is true. A transition is specified by giving the new values of the variables in the module, possibly as a function of other variables. Each update is also assigned a probability (or in some cases a rate) which will be assigned to the corresponding transition.
</p><hr />
<h1>Example 1</h1>
<p>We will use the following simple example to illustrate the basic concepts of the PRISM language.
Consider a system comprising two identical processes which must operate under mutual exclusion.
Each process can be in one of 3 states: {0,1,2}.
From state 0, a process will move to state 1 with probability 0.2
and remain in the same state with probability 0.8.
From state 1, it tries to move to the critical section: state 2.
This can only occur if the other process is not in its critical section.
Finally, from state 2, a process will either remain there or move back to state 0
with equal probability.
The PRISM code to describe this system can be seen below.
In the next sections, we explain each aspect of the code in turn.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismcomment">// Example 1</span><br/>
<span class="prismcomment">// Two process mutual exclusion</span><br/>
<br/>
<span class="prismkeyword">mdp</span><br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">M1</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span> : [<span class="prismnum">0</span>..<span class="prismnum">2</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">x</span>=<span class="prismnum">1</span> &amp; <span class="prismident">y</span>!=<span class="prismnum">2</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">x</span>=<span class="prismnum">2</span> -&gt; <span class="prismnum">0.5</span>:(<span class="prismident">x</span>'=<span class="prismnum">2</span>) + <span class="prismnum">0.5</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">M2</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">y</span> : [<span class="prismnum">0</span>..<span class="prismnum">2</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">y</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">y</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">y</span>'=<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">y</span>=<span class="prismnum">1</span> &amp; <span class="prismident">x</span>!=<span class="prismnum">2</span> -&gt; (<span class="prismident">y</span>'=<span class="prismnum">2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">y</span>=<span class="prismnum">2</span> -&gt; <span class="prismnum">0.5</span>:(<span class="prismident">y</span>'=<span class="prismnum">2</span>) + <span class="prismnum">0.5</span>:(<span class="prismident">y</span>'=<span class="prismnum">0</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'  style='text-align: center;'><strong>The PRISM Language: Example 1</strong>
</p><hr />
<h1>Model Type</h1>
<p>The PRISM language can be used to describe three types of probabilistic models:
discrete-time Markov chains (DTMCs), continuous-time Markov chains (CTMCs)
and Markov decision processes (MDPs).
To indicate which type is being described, a PRISM model includes one of the keywords
<code><strong>dtmc</strong></code>, <code><strong>ctmc</strong></code> or <code><strong>mdp</strong></code>.
This is typically at the very start of the file (as in <a class='wikilink' href='../ThePRISMLanguage/Example1.html'>Example 1</a>),
but can actually occur anywhere in the file (except inside modules and other declarations).
The keywords <code><strong>probabilistic</strong></code>, <code><strong>stochastic</strong></code> and <code><strong>nondeterministic</strong></code>
can be used as alternatives for <code><strong>dtmc</strong></code>, <code><strong>dtmc</strong></code> and <code><strong>mdp</strong></code>, respectively.
If no such model type declaration is included, the model is by default assumed to be an MDP.
</p>
<div class='vspace'></div><hr />
<h1>Modules And Variables</h1>
<p>The <a class='wikilink' href='../ThePRISMLanguage/Example1.html'>previous example</a> uses two modules, <code>M1</code> and <code>M2</code>, one representing each process.
A module is specified as:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">module</span> <span class="prismident">name</span> ... <span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'>The definition of a module contains two parts: its variables and its guards.
In this example, each module has one integer variable with range <code>[0..2]</code>.
A variable declaration looks like:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismident">x</span> : [<span class="prismnum">0</span>..<span class="prismnum">2</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>;<br/>
</div></div>
</div>
<p class='vspace'>Notice that the initial value of the variable is also specified.
See the next subsection for more information about this subject.
Boolean variables can also be used, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismident">b</span> : <span class="prismkeyword">bool</span> <span class="prismkeyword">init</span> <span class="prismkeyword">false</span>;<br/>
</div></div>
</div>
<p class='vspace'>The names given to modules and variables are referred to as <em>identifiers</em>.
Identifiers can be made up of letters, digits and the underscore character, but cannot begin with a digit,
i.e. they must satisfy the regular expression [A-Za-z_][A-Za-z0-9_]*, and are case-sensitive.
Furthermore, identifiers cannot be any of the following, which are all reserved keywords in PRISM:
<code><strong>A</strong></code>, <code><strong>bool</strong></code>, <code><strong>const</strong></code>, <code><strong>ctmc</strong></code>, <code><strong>C</strong></code>, <code><strong>double</strong></code>, <code><strong>dtmc</strong></code>, <code><strong>E</strong></code>, <code><strong>endinit</strong></code>, <code><strong>endmodule</strong></code>, <code><strong>endrewards</strong></code>, <code><strong>endsystem</strong></code>, <code><strong>false</strong></code>, <code><strong>formula</strong></code>, <code><strong>func</strong></code>, <code><strong>F</strong></code>, <code><strong>global</strong></code>, <code><strong>G</strong></code>, <code><strong>init</strong></code>, <code><strong>I</strong></code>, <code><strong>int</strong></code>, <code><strong>label</strong></code>, <code><strong>max</strong></code>, <code><strong>mdp</strong></code>, <code><strong>min</strong></code>, <code><strong>module</strong></code>, <code><strong>X</strong></code>, <code><strong>nondeterministic</strong></code>, <code><strong>Pmax</strong></code>, <code><strong>Pmin</strong></code>, <code><strong>P</strong></code>, <code><strong>probabilistic</strong></code>, <code><strong>prob</strong></code>, <code><strong>rate</strong></code>, <code><strong>rewards</strong></code>, <code><strong>Rmax</strong></code>, <code><strong>Rmin</strong></code>, <code><strong>R</strong></code>, <code><strong>S</strong></code>, <code><strong>stochastic</strong></code>, <code><strong>system</strong></code>, <code><strong>true</strong></code>, <code><strong>U</strong></code>, <code><strong>W</strong></code>, 
</p><hr />
<h1>Initial States</h1>
<p>The state space of a probabilistic model described in the PRISM language
is the set of all possible valuations of its variables.
The set of initial states of the model can be specified in one of two ways.
The most common approach is simply to specify an initial value for each variable in the model.
This is done in the declaration of each variable, as illustrated in <a class='wikilink' href='../ThePRISMLanguage/Example1.html'>Example 1</a>
and as discussed in the previous section.
If the initial value of a variable is omitted from its declaration,
it is taken to be the minimum value of the variable's range.
</p>
<p class='vspace'>This approach results in a single initial state.
It is also possible to construct a model with multiple initial states.
This is done using the <code><strong>init</strong>...<strong>endinit</strong></code> construct,
which can be placed anywhere in the file except within a module definition,
and removing any initial values from variable declarations.
Between the <code><strong>init</strong></code> and <code><strong>endinit</strong></code> keywords, there should be a
predicate over all the variables of the model.
Any state which satisfies this predicate is an initial state.
</p>
<p class='vspace'>Consider <a class='wikilink' href='../ThePRISMLanguage/Example1.html'>Example 1</a>.
As it stands, there is a single initial state <code>(0,0)</code> (i.e.  <code>x=0</code> and <code>y=0</code>).
If we remove the <code><strong>init</strong> 0</code> part of both variable declarations
and add the following to the end of the file:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">init</span> <span class="prismident">x</span>=<span class="prismnum">0</span> <span class="prismkeyword">endinit</span><br/>
</div></div>
</div>
<p class='vspace'>there will be three initial states: <code>(0,0)</code>, <code>(0,1)</code> and <code>(0,2)</code>.
Similarly, we could instead add:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">init</span> <span class="prismident">x</span>+<span class="prismident">y</span>=<span class="prismnum">1</span> <span class="prismkeyword">endinit</span><br/>
</div></div>
</div>
<p class='vspace'>in which case there would be two initial states: <code>(0,1)</code> and <code>(1,0)</code>.
</p><hr />
<h1>Commands</h1>
<p>The behaviour of each module is described by commands, comprising a guard and one or more updates.
The first command of module <code>M1</code> in our example is:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>The guard <code>x=0</code> indicates that this describes the behaviour of the module when the variable <code>x</code> has value 0.
The updates <code>(x'=0)</code> and <code>(x'=1)</code> and their associated probabilities state that the value of <code>x</code> will
remain at 0 with probability 0.8 and change to 1 with probability 0.2.
For DTMCs and MDPs, we require that the probabilities on the right hand side of a command sum to one.
Note that the inclusion of updates in parentheses, e.g. <code>(x'=1)</code>, is essential.
While older versions of PRISM did not report the absence of parentheses as an error, newer versions do.
</p>
<p class='vspace'>The second command:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">1</span> &amp; <span class="prismident">y</span>!=<span class="prismnum">2</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">2</span>);<br/>
</div></div>
</div>
<p class='vspace'>illustrates that guards can contain constraints on any variable, not just the ones in that module,
i.e. the behaviour of one module can depend on the state of another.
Updates, however, can only specify values for variables belonging to the module.
The command above also shows that, when there is a single update with probability 1, the <code>1.0:</code> can be omitted.
</p>
<p class='vspace'>If a module has more than one variable, updates describe the new value for each of them.
For example, if it had two variables <code>x1</code> and <code>x2</code>, a possible command would be:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x1</span>=<span class="prismnum">0</span> &amp; <span class="prismident">x2</span>&gt;<span class="prismnum">0</span> -&gt; <span class="prismnum">0.5</span>:(<span class="prismident">x1</span>'=<span class="prismnum">1</span>)&amp;(<span class="prismident">x2</span>'=<span class="prismident">x2</span>+<span class="prismnum">1</span>) + <span class="prismnum">0.5</span>:(<span class="prismident">x1</span>'=<span class="prismnum">2</span>)&amp;(<span class="prismident">x2</span>'=<span class="prismident">x2</span>-<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>Notice that elements of the updates are concatenated with <code>&amp;</code> and that each element must be bracketed individually.
If an update does not give a new value for a local variable, it is assumed not to change.
As a special case, the keyword <code><strong>true</strong></code> can be used to denote an update where no variable's value changes.
</p><hr />
<h1>Parallel Composition</h1>
<p>The probabilistic model corresponding to a PRISM language description is constructed as the parallel composition of its modules.
In every state of the model, there is a set of commands (belonging to any of the modules) which are enabled,
i.e. whose guards are satisfied in that state.
The choice between which command is performed (i.e. the scheduling) depends on the model type.
For an MDP, as in Example 1, the choice is <em>nondeterministic</em>.
By way of example, consider state <code>(0,0)</code> (i.e.  <code>x=0</code> and <code>y=0</code>).
In the MDP, there would be a nondeterministic choice between two probability distributions:
</p>
<div class='vspace'></div><ul><li><code>0.8:(0,0) + 0.2:(1,0)</code> (module <code>M1</code> moves)
</li><li><code>0.8:(0,0) + 0.2:(0,1)</code> (module <code>M2</code> moves)
</li></ul><p class='vspace'>For a DTMC, the choice is <em>probabilistic</em>: each enabled command is selected with equal probability.
If Example 1 was a DTMC, then in state <code>(0,0)</code> of the model
the following probability distribution would result:
</p>
<div class='vspace'></div><ul><li><code>0.8:(0,0) + 0.1:(1,0) + 0.1:(0,1)</code>
</li></ul><p class='vspace'>For a CTMC, the choice is modelled as a "race" between transitions.
</p><hr />
<h1>Local Nondeterminism</h1>
<p>PRISM models which are MDPs can also exhibit <em>local nondeterminism</em>,
which allows the modules themselves to make nondeterministic choices.
In Example 1, we can make the probabilistic choice in the first state of module <code>M1</code> nondeterministic by replacing the command:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>with the commands:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">0</span>);<br/>
[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>Assuming we do the same for module <code>M2</code>, in state <code>(0,0)</code> of the MDP
there will be a nondeterministic choice between three (trivial) probability distributions:
</p>
<div class='vspace'></div><ul><li><code>1.0:(0,0)</code>
</li><li><code>1.0:(1,0)</code>
</li><li><code>1.0:(0,1)</code>
</li></ul><p class='vspace'>PRISM also permits local nondeterminism in models which are DTMCs,
although the nondeterministic choice is randomised when the parallel composition of the modules occurs.
Since the appearance of nondeterminism in a DTMC is often the result of
a user error in the model specification, PRISM displays a warning when local nondeterminism is detected in a DTMC.
</p><hr />
<h1>Module Renaming</h1>
<p>PRISM also supports <em>module renaming</em>, which allows duplication of modules.
In Example 1, module <code>M2</code> is identical to module <code>M1</code> so we can in fact replace its entire definition with:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">module</span> <span class="prismident">M2</span> = <span class="prismident">M1</span> [ <span class="prismident">x</span>=<span class="prismident">y</span>, <span class="prismident">y</span>=<span class="prismident">x</span> ] <span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'>Note that this renaming is done at a textual level, so any identifiers (including <a class='wikilink' href='../ThePRISMLanguage/Synchronisation.html'>action labels</a>, <a class='wikilink' href='../ThePRISMLanguage/Constants.html'>constants</a> and <a class='wikilink' href='../ThePRISMLanguage/Expressions.html'>functions</a>)
used in the module definition can be changed in this way.
All of the variables in the module being renamed (in this case, just <code>x</code>) must be renamed to new, unused names.
</p><hr />
<h1>Example 2</h1>
<p>We now introduce a second example, which is a model of an <em>N</em>-place queue of jobs and
a server which removes jobs from the queue and processes them.
The PRISM code can be found below.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismcomment">// Example 2</span><br/>
<span class="prismcomment">// N-place queue + server</span><br/>
<br/>
<span class="prismkeyword">ctmc</span><br/>
<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">N</span> = <span class="prismnum">10</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">mu</span> = <span class="prismnum">1</span>/<span class="prismnum">10</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">lambda</span> = <span class="prismnum">1</span>/<span class="prismnum">2</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">gamma</span> = <span class="prismnum">1</span>/<span class="prismnum">3</span>;<br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">queue</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">q</span> : [<span class="prismnum">0</span>..<span class="prismident">N</span>];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">q</span>&lt;<span class="prismident">N</span> -&gt; <span class="prismident">mu</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>+<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">q</span>=<span class="prismident">N</span> -&gt; <span class="prismident">mu</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">serve</span>] <span class="prismident">q</span>&gt;<span class="prismnum">0</span> -&gt; <span class="prismident">lambda</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>-<span class="prismnum">1</span>);<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">server</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">s</span> : [<span class="prismnum">0</span>..<span class="prismnum">1</span>];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">serve</span>] <span class="prismident">s</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">1</span>:(<span class="prismident">s</span>'=<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">s</span>=<span class="prismnum">1</span> -&gt; <span class="prismident">gamma</span>:(<span class="prismident">s</span>'=<span class="prismnum">0</span>);<br/>
<span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'  style='text-align: center;'><strong>The PRISM Language: Example 2</strong>
</p>
<p class='vspace'>As can be seen from the start of the file,
the model is a continuous-time Markov chain (CTMC).
One of the main differences, therefore, is that transitions of modules are
labelled with (positive-valued) <em>rates</em>, rather than probabilities.
The notation used in commands, however, to associate rates to transitions is identical to
that used to assign probabilities in DTMCs and MDPs:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismident">rate_1</span>:<span class="prismident">update_1</span> + <span class="prismident">rate_2</span>:<span class="prismident">update_2</span> + ...<br/>
</div></div>
</div>
<p class='vspace'>Example 2 also introduces a number of other PRISM language concepts:
constants, action labels and synchronisation.
These are described in the following sections.
</p><hr />
<h1>Constants</h1>
<p>PRISM also supports the use of <em>constants</em>, as seen in <a class='wikilink' href='../ThePRISMLanguage/Example2.html'>Example 2</a>.
Constants can be integers, doubles or Booleans
and can be defined using literal values or as constant expressions (including in terms of each other) using the <code><strong>const</strong></code>
keyword. For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">radius</span> = <span class="prismnum">12</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">pi</span> = <span class="prismnum">3.141592</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">area</span> = <span class="prismident">pi</span> * <span class="prismident">radius</span> * <span class="prismident">radius</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">bool</span> <span class="prismident">yes</span> = <span class="prismkeyword">true</span>;<br/>
</div></div>
</div>
<p class='vspace'>The identifiers used for their names are subject to the same rules as <a class='wikilink' href='../ThePRISMLanguage/ModulesAndVariables.html'>variables</a>.
</p>
<p class='vspace'>Constants can be used anywhere that a constant value would be expected,
such as the lower or upper range of a variable (e.g. <code>N</code> in Example 2),
the probability or rate associated with an update (<code>mu</code> in Example 2),
or anywhere in a guard or update.
As will be described later constants can also be left undefined
and specified later, either to a single value or a range of values, using <a class='wikilink' href='../RunningPRISM/Experiments.html'>experiments</a>.
</p>
<p class='vspace'><strong>Note:</strong> For the sake of backward-compatibility, the notation used in earlier versions of PRISM
(<code><strong>const</strong></code> for <code><strong>const int</strong></code> and <code><strong>rate</strong></code> or <code><strong>prob</strong></code> for <code><strong>const double</strong></code>) is still supported.
</p><hr />
<h1>Expressions</h1>
<p>The definition of the <code>area</code> constant, in the example above, uses an <em>expression</em>.
We now define more precisely what types of expression are supported by PRISM.
Expressions can contain literal values (12, 3.141592, <code><strong>true</strong></code>, <code><strong>false</strong></code>, etc.),
identifiers (corresponding to variables, constants, etc.) and operators from the following list:
</p>
<div class='vspace'></div><ul><li><code>-</code> (unary minus)
</li><li><code>*</code>, <code>/</code> (multiplication, division)
</li><li><code>+</code>, <code>-</code> (addition, subtraction)
</li><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code> (relational operators)
</li><li><code>=</code>, <code>!=</code> (equality operators)
</li><li><code>!</code> (negation)
</li><li><code>&amp;</code> (conjunction)
</li><li><code>|</code> (disjunction)
</li><li><code>=&gt;</code> (implication)
</li><li><code>?</code> (condition evaluation: <code>condition ? a : b</code> means "if <code>condition</code> is true then <code>a</code> else <code>b</code>")
</li></ul><p class='vspace'>All of these operators except <code>?</code> are left associative
(i.e. they are evaluated from left to right).
The precedence of the operators is as found in the list above,
most strongly binding operators first.
Operators on the same line (e.g. <code>+</code> and <code>-</code>) are of equal precedence.
</p>
<p class='vspace'>The notation for expressions is hence essentially equivalent to that of C/C++ or Java.
One notable exception to this is that  the division operator <code>/</code> always performs floating point, not integer, division,
i.e. the result of <code>22/7</code> is 3.142857... not 3.
All expressions must evaluate correctly in terms of type (integer, double or Boolean).
</p>
<p class='vspace'><strong>Built-in Functions</strong>
</p>
<p class='vspace'>Expressions can make use of several built-in functions:
</p>
<div class='vspace'></div><ul><li><code>min(...)</code> and <code>max(...)</code>, which select the minimum and maximum value, respectively, of two or more numbers;
</li><li><code>floor(x)</code> and <code>ceil(x)</code>, which round <code>x</code> down and up, respectively, to the nearest integer;
</li><li><code>pow(x,y)</code> which computes <code>x</code> to the power of <code>y</code>;
</li><li><code>mod(i,n)</code> for integer modulo operations;
</li><li><code>log(x,b)</code>, which computes the logarithm of <code>x</code> to base <code>b</code>.
</li></ul><p class='vspace'>Examples of their usage are:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">min</span>(<span class="prismident">x</span>+<span class="prismnum">1</span>, <span class="prismident">x_max</span>)<br/>
<span class="prismkeyword">max</span>(<span class="prismident">a</span>,<span class="prismident">b</span>,<span class="prismident">c</span>)<br/>
<span class="prismident">floor</span>(<span class="prismnum">13.5</span>)<br/>
<span class="prismident">ceil</span>(<span class="prismnum">13.5</span>)<br/>
<span class="prismident">pow</span>(<span class="prismnum">2</span>, <span class="prismnum">8</span>)<br/>
<span class="prismident">pow</span>(<span class="prismnum">9.0</span>, <span class="prismnum">0.5</span>)<br/>
<span class="prismident">mod</span>(<span class="prismnum">1977</span>, <span class="prismnum">100</span>)<br/>
<span class="prismident">log</span>(<span class="prismnum">123</span>, <span class="prismnum">2.71828183</span>)<br/>
</div></div>
</div>
<p class='vspace'>For compatability with older versions of PRISM, all functions can also be expressed via the <code><strong>func</strong></code> keyword, e.g. <code>func(floor, 13.5)</code>.
</p>
<p class='vspace'><strong>Use of Expressions</strong>
</p>
<p class='vspace'>Expressions can be used in a wide range of places in a PRISM language description, e.g.:
</p>
<div class='vspace'></div><ul><li>constant definitions
</li><li>lower/upper bounds and initial values for variables
</li><li>guards
</li><li>probabilities/rates
</li><li>updates
</li></ul><p class='vspace'>This allows, for example, the probability in a command to be dependent on the current state:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] (<span class="prismident">x</span>&gt;=<span class="prismnum">1</span> &amp; <span class="prismident">x</span>&lt;=<span class="prismnum">10</span>) -&gt; <span class="prismident">x</span>/<span class="prismnum">10</span> : (<span class="prismident">x</span>'=<span class="prismkeyword">max</span>(<span class="prismnum">1</span>,<span class="prismident">x</span>-<span class="prismnum">1</span>)) + <span class="prismnum">1</span>-<span class="prismident">x</span>/<span class="prismnum">10</span> : (<span class="prismident">x</span>'=<span class="prismkeyword">min</span>(<span class="prismnum">10</span>,<span class="prismident">x</span>+<span class="prismnum">1</span>))<br/>
</div></div>
</div>
<hr />
<h1>Synchronisation</h1>
<p>Another feature of PRISM introduced in Example 2 is <em>synchronisation</em>.
In the style of many process algebras, we allow commands to be labelled with <em>actions</em>.
These are placed inside the square brackets which mark the start of the command,
for example <code>serve</code> in this command from <a class='wikilink' href='../ThePRISMLanguage/Example2.html'>Example 2</a>:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[<span class="prismident">serve</span>] <span class="prismident">q</span>&gt;<span class="prismnum">0</span> -&gt; <span class="prismident">lambda</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>-<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>These actions can be used to force two or more modules to make transitions simultaneously
(i.e. to <em>synchronise</em>).
For example, in state <code>(3,0)</code> (i.e.  <code>q=3</code> and <code>s=0</code>),
the composed model can move to state <code>(2,1)</code>,
synchronising over the <code>serve</code> action.
The rate of this transition is equal to the product of the two individual rates
(in this case, <code>lambda * 1 = lambda</code>).
The product of two rates does not always meaningfully represent the rate of a synchronised transition.
A common technique, as seen here, is to make one action <em>passive</em>, with rate 1 and one action <em>active</em>,
which actually defines the rate for the synchronised transition.
By default, all modules are combined using the standard CSP parallel composition
(i.e. modules synchronise over all their common actions).
</p><hr />
<h1>Process Algebra Operators</h1>
<p>To make the concept of synchronisation described above more powerful,
PRISM allows you to define precisely the way in which the set of modules are composed in parallel.
This is specified using the <code><strong>system</strong> ... <strong>endsystem</strong></code> construct,
placed at the end of the model description, which should contain a process-algebraic expression.
This expression should feature each module exactly once, and can use the following (CSP-based) operators:
</p>
<div class='vspace'></div><ul><li><code>M1 || M2</code> : alphabetised parallel composition of modules <code>M1</code> and <code>M2</code> (synchronising on only actions appearing in both <code>M1</code> and <code>M2</code>)
<div class='vspace'></div></li><li><code>M1 ||| M2</code> : asynchronous parallel composition of <code>M1</code> and <code>M2</code> (fully interleaved, no synchronisation)
<div class='vspace'></div></li><li><code>M1 |[a,b,...]| M2</code> : restricted parallel composition of modules <code>M1</code> and <code>M2</code> (synchronising only on actions from the set {<code>a</code>, <code>b</code>,...})
<div class='vspace'></div></li><li><code>M / {a,b,...</code>} : hiding of actions {<code>a</code>, <code>b</code>, ...} in module <code>M</code>
<div class='vspace'></div></li><li><code>M {a&lt;-b,c&lt;-d,...</code>} : renaming of actions <code>a</code> to <code>b</code>, <code>c</code> to <code>d</code>, etc. in module <code>M</code>.
</li></ul><p class='vspace'>The first two types of parallel composition (<code>||</code> and <code>|||</code>) are associative and can be applied to more than two modules at once.
When evaluating the expression, the hiding and renaming operators bind more tightly than the three parallel composition operators.
No other rules of precedence are defined and parentheses should be used to specify the order in which modules are composed.
</p>
<p class='vspace'>Some examples of expressions which could be included in the <code><strong>system</strong> ... <strong>endsystem</strong></code> construct are as follows:
</p>
<div class='vspace'></div><ul><li><code>(station1 ||| station2 ||| station3) |[serve]| server</code>
</li><li><code>((P1 |[a]| P2) / {a}) || Q</code>
</li><li><code>((P1 |[a]| P2) {a&lt;-b}) |[b]| Q</code>
</li></ul><p class='vspace'>When no parallel composition is specified by the user,
PRISM implicitly assumes an expression of the form <code>M1 || M2 || ...</code> containing all of the modules in the model.
For a more formal definition of the process algebra operators described above, check the semantics of the PRISM language, available from the "<a class='urllink' href='http://www.prismmodelchecker.org/doc/'>Documentation</a>" section of the PRISM web site.
</p>
<p class='vspace'>PRISM is also able to <a class='wikilink' href='../RunningPRISM/SupportForPEPAModels.html'>import</a> model descriptions written in (a subset of) the stochastic process algebra <a class='urllink' href='http://www.dcs.ed.ac.uk/pepa/'>PEPA</a> [<a class='wikilink' href='References.html#Hil96'>Hil96</a>].
</p><hr />
<h1>Global Variables</h1>
<p>In addition to the local variables belonging to each module, a PRISM model can also include <em>global variables</em>,
which can be written to, as well as read, by all modules.
Like local variables, these can be integers or Booleans.
Global variables are declared in identical fashion to a module's local variables,
except that the declaration must not be inside the definition of any module.
Some example declarations are as follows:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">global</span> <span class="prismident">g</span> : [<span class="prismnum">1</span>..<span class="prismnum">10</span>];<br/>
<span class="prismkeyword">global</span> <span class="prismident">b</span> : <span class="prismkeyword">bool</span> <span class="prismkeyword">init</span> <span class="prismkeyword">true</span>;<br/>
</div></div>
</div>
<p class='vspace'>A global variable can be modified by any module and provides another way for modules to interact.
An important restriction on the use of global variables is the fact that commands which synchronise with other modules
(i.e. those with an action label attached; see the section "<a class='wikilink' href='../ThePRISMLanguage/Synchronisation.html'>Synchronisation</a>") cannot modify global variables.
PRISM will detect this and report an error.
</p><hr />
<h1>Formulas And Labels</h1>
<p>PRISM models can include <em>formulas</em> which are used to avoid duplication of code.
A formula comprises a name (an identifier) and an <a class='wikilink' href='../ThePRISMLanguage/Expressions.html'>expression</a>.
The formula name can then be used as shorthand for the expression anywhere an expression might usually be accepted.
A formula is defined as follows:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">formula</span> <span class="prismident">lfree</span> = <span class="prismident">p2</span>=<span class="prismnum">0</span>..<span class="prismnum">4</span>,<span class="prismnum">6</span>,<span class="prismnum">10</span>;<br/>
</div></div>
</div>
<p class='vspace'>It can then be used anywhere within that file, as for example in this command:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">p1</span>=<span class="prismnum">2</span> &amp; <span class="prismident">lfree</span> -&gt; (<span class="prismident">p1</span>'=<span class="prismnum">4</span>);<br/>
</div></div>
</div>
<p class='vspace'>The effect is exactly as if the following had been typed:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">p1</span>=<span class="prismnum">2</span> &amp; (<span class="prismident">p2</span>=<span class="prismnum">0</span>..<span class="prismnum">4</span>,<span class="prismnum">6</span>,<span class="prismnum">10</span>) -&gt; (<span class="prismident">p1</span>'=<span class="prismnum">4</span>);<br/>
</div></div>
</div>
<p class='vspace'>Formulas defined in a model can also be used when specifying its properties.
</p>
<div class='vspace'></div><h3>Formulas and renaming</h3>
<p>During parsing of the model, expansion of formulas is done before module renaming so, if a module which uses formulas is renamed to another module, it is the contents of the formula which will be renamed, not the formula itself.
</p>
<div class='vspace'></div><h3>Labels</h3>
<p>PRISM models can also contain <em>labels</em>. These are are a way of identifying sets of states that are of particular interest. Labels can only be used when specifying <a class='wikilink' href='../PropertySpecification/Introduction.html'>properties</a> but, for convenience, can be defined in model files as well as property files. 
</p>
<p class='vspace'>Labels differ from formulas in two other ways: firstly, they must be of Boolean type;
secondly, they are written using quotation marks (<code>"..."</code>), as illustrated in the following example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">label</span> "<span class="prismident">safe</span>" = <span class="prismident">temp</span>&lt;=<span class="prismnum">100</span> | <span class="prismident">alarm</span>=<span class="prismkeyword">true</span>;<br/>
<span class="prismkeyword">label</span> "<span class="prismident">fail</span>" = <span class="prismident">temp</span>&gt;<span class="prismnum">100</span> &amp; <span class="prismident">alarm</span>=<span class="prismkeyword">false</span>;<br/>
</div></div>
</div>
<hr />
<h1>PRISM Language Files</h1>
<p>Files containing model descriptions written in the PRISM language
can contain any amount of white space (spaces, tabs, new lines, etc.),
all of which is ignored when the file is parsed by the tool.
Comments can also be used included in files in the style of the C programming language,
by preceding them with the characters <code>//</code>.
This is illustrated by the PRISM language examples from earlier in this section.
By convention, PRISM model files which describe MDPs, DTMCs and CTMCs are given the extensions 
<code>.nm</code>, <code>.pm</code> and <code>.sm</code>, respectively.
</p><hr />
<h1>Costs And Rewards </h1>
<p>PRISM now includes support for the specification and analysis of
properties based on <em>costs</em> and <em>rewards</em>.
This means that PRISM can be used to reason,
not just about the probability that a model behaves in a certain fashion,
but about a wider range of quantitative measures relating to model behaviour.
For example, PRISM can be used to compute properties such as
"expected time", "expected number of lost messages" or "expected power consumption".
The implementation of cost- and reward-based techniques in the tool is only partially completed and is still ongoing.
If you have questions, comments or feature-requests relating to this functionality,
please feel free to contact the PRISM team about this.
</p>
<p class='vspace'>The basic idea is that probabilistic models (of all three types) developed in PRISM
can be augmented with costs or rewards: real values associated with certain states or transitions of the model.
In fact, since there is no practical distinction between costs and rewards
(except that costs are generally perceived to be "bad" and rewards to be "good"),
PRISM only supports rewards.
The user is, however, free to interpret the values however they choose.
</p>
<p class='vspace'>In this section, we describe how models described in the PRISM language
can be augmented with rewards.
Later, we will discuss how to express properties that relate to these rewards.
Rewards are associated with models using <code><strong>rewards</strong> ... <strong>endrewards</strong></code> constructs,
which can appear anywhere in a model file except within a module definition.
These constructs contains one or more <em>reward items</em>.
Consider the following simple example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>This assigns a reward of 1 to every state of the model.
It comprises a single reward item, the left part of which (<code><strong>true</strong></code>) is a guard
and the right part of which (<code>1</code>) is a reward.
States of the model which satisfy the predicate in the guard are assigned the corresponding reward.
More generally, state rewards can be specified using multiple reward items,
each of the form <code>guard : reward;</code>,
where <code>guard</code>is a predicate (over all the variables of the model)
and <code>reward</code> is an expression (containing any variables, constants, etc. from the model).
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span>=<span class="prismnum">0</span> : <span class="prismnum">100</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span>&gt;<span class="prismnum">0</span> &amp; <span class="prismident">x</span>&lt;<span class="prismnum">10</span> : <span class="prismnum">2</span>*<span class="prismident">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span>=<span class="prismnum">10</span> : <span class="prismnum">100</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>assigns a reward of 100 to states satisfying <code>x=0</code> or <code>x=10</code>
and a reward of <code>2*x</code> to states satisfying <code>x&gt;0 &amp; x&lt;10</code>.
Note that a single reward item can assign different rewards to different states,
depending on the values of model variables in each one.
Any states which do not satisfy the guard of any reward item will have no reward assigned to them.
For states which satisfy multiple guards, the reward assigned to the state
is the sum of the rewards for all the corresponding reward items.
</p>
<p class='vspace'>Rewards can also be assigned to transitions of a model.
These are specified in a similar fashion to state rewards,
within the <code><strong>rewards</strong> ... <strong>endrewards</strong></code> construct.
Reward items describing transition rewards are of the form <code>[action] guard : reward;</code>,
the interpretation being that transitions from states which satisfy the guard <code>guard</code>
and are labelled with the action <code>action</code> acquire the reward <code>reward</code>.
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">a</span>] <span class="prismkeyword">true</span> : <span class="prismident">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">b</span>] <span class="prismkeyword">true</span> : <span class="prismnum">2</span>*<span class="prismident">x</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>assigns a reward of 1 to all transitions in the model with no action label,
and rewards of <code>x</code> and <code>2*x</code> to all transitions labelled with actions <code>a</code> and <code>b</code>, respectively.
</p>
<p class='vspace'>As is the case for states, multiple reward items can specify rewards for a single transition,
in which case the resulting reward is the sum of all the individual rewards.
A model description can specify rewards for both states and transitions.
These are all placed together in a single <code><strong>rewards</strong>...<strong>endrewards</strong></code> construct.
</p>
<p class='vspace'>A PRISM model can have multiple reward structures. Optionally, these can be given labels such as in the following example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span> "<span class="prismident">total_time</span>"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
<br/>
<span class="prismkeyword">rewards</span> "<span class="prismident">num_failures</span>"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">fail</span>] <span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'><br /><br />
</p><hr />
<div class='vspace'></div><h1><span class='big'>Property Specification</span></h1>
<hr />
<h1>Introduction</h1>
<p>In order to analyse a probabilistic model which has been specified and constructed in PRISM,
it is necessary to identify one or more <em>properties</em> of the model
which can be evaluated by the tool.
PRISM's <em>property specification language</em> subsumes several well-known probabilistic temporal logics, including PCTL, CSL, LTL and PCTL*.
PCTL is used for specifying properties of DTMCs and MDPs;
CSL is an extension of PCTL for CTMCs;
LTL and PCTL* can be used to specify properties of 
DTMCs and MDPs (or untimed properties of CTMCs).
</p>
<p class='vspace'>In fact, PRISM also supports numerous additional customisations and extensions of these two logics.
Full details of the property specifications permitted in PRISM are provided in the following sections. The presentation given here is relatively informal. For the precise syntax and semantics of the various logics, see [<a class='wikilink' href='References.html#HJ94'>HJ94</a>],[<a class='wikilink' href='References.html#BdA95'>BdA95</a>] for PCTL, [<a class='wikilink' href='References.html#ASSB96'>ASSB96</a>],[<a class='wikilink' href='References.html#BKH99'>BKH99</a>] for CSL and, for example, [<a class='wikilink' href='References.html#Bai98'>Bai98</a>] for LTL and PCTL*. You can also find various pointers to useful papers in the <a class='urllink' href='http://www.prismmodelchecker.org/about.php'>About</a> and <a class='urllink' href='http://www.prismmodelchecker.org/doc/'>Documentation</a> sections of the PRISM website.
</p>
<p class='vspace'>Before discussing property specifications in more detail,
it is perhaps instructive to first illustrate some typical examples of properties which PRISM can handle.
The following are a selection of such properties.
In each case, we give both the PRISM syntax and a natural language translation:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">1</span> [ <span class="prismkeyword">F</span> "<span class="prismident">terminate</span>" ]<br/>
</div></div>
</div>
<p>"the algorithm eventually terminates successfully with probability 1"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">"<span class="prismkeyword">init</span>" =&gt; <span class="prismkeyword">P</span>&lt;<span class="prismnum">0.1</span> [ <span class="prismkeyword">F</span>&lt;=<span class="prismnum">100</span> <span class="prismident">num_errors</span> &gt; <span class="prismnum">5</span> ]<br/>
</div></div>
</div>
<p>"from any initial state, the probability that more than 5 errors occur within the first 100 time units is less than 0.1"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">"<span class="prismident">down</span>" =&gt; <span class="prismkeyword">P</span>&gt;<span class="prismnum">0.75</span> [ !"<span class="prismident">fail</span>" <span class="prismkeyword">U</span>[<span class="prismnum">1</span>,<span class="prismnum">2</span>] "<span class="prismident">up</span>" ]<br/>
</div></div>
</div>
<p>"when a shutdown occurs, the probability of system recovery being completed in between 1 and 2 hours without further failures occurring is greater than 0.75"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">S</span>&lt;<span class="prismnum">0.01</span> [ <span class="prismident">num_sensors</span> &lt; <span class="prismident">min_sensors</span> ]<br/>
</div></div>
</div>
<p>"in the long-run, the probability that an inadequate number of sensors are operational is less than 0.01"
</p>
<p class='vspace'>Note that the above properties are all assertions,
i.e. ones to which we would expect a "yes" or "no" answer.
This is because all references to probabilities are associated with an upper or lower bound
which can be checked to be either true or false.
In PRISM, we can also directly specify properties which evaluate to a numerical value, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ !<span class="prismident">proc2_terminate</span> <span class="prismkeyword">U</span> <span class="prismident">proc1_terminate</span> ]<br/>
</div></div>
</div>
<p>"the probability that process 1 terminates before process 2 does"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">Pmax</span>=? [ <span class="prismkeyword">F</span>&lt;=<span class="prismident">T</span> <span class="prismident">messages_lost</span> &gt; <span class="prismnum">10</span> ]<br/>
</div></div>
</div>
<p>"the maximum probability that more than 10 messages have been lost by time <code>T</code>"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">S</span>=? [ <span class="prismident">queue_size</span> / <span class="prismident">max_size</span> &gt; <span class="prismnum">0.75</span> ]<br/>
</div></div>
</div>
<p>"the long-run probability that the queue is more than 75% full"
</p>
<p class='vspace'>Furthermore, PRISM makes it easy to combine such properties into more complex expressions,
compute their values for a range of parameters
and plot graphs of the results using <a class='wikilink' href='../RunningPRISM/Experiments.html'>experiments</a>.
This is often a very useful way of identifying interesting
patterns or trends in the behaviour of a system.
See the <a class='urllink' href='http://www.prismmodelchecker.org/casestudies/'>Case Studies</a> section of the <a class='urllink' href='http://www.prismmodelchecker.org/'>PRISM website</a> for many examples of this kind of analysis.
</p><hr />
<h1>Identifying A Set Of States</h1>
<p>One of the most fundamental tasks when specifying properties of a model
is to identify particular sets or classes of states of the model.
For example, to verify a property such as
"the algorithm eventually terminates successfully with probability 1",
it is first necessary to identify the states of the model
which correspond to situations where "the algorithm has terminated successfully".
In terms of the way temporal logics are usually presented,
these correspond to <em>atomic propositions</em>.
</p>
<p class='vspace'>In PRISM, this is achieved simply by writing an <a class='wikilink' href='../ThePRISMLanguage/Expressions.html'>expression</a> in the PRISM language which evaluates to a Boolean value. This expression will typically contain references to variables (and constants) from the model to which it relates. The set of states corresponding to this expression is those for which it evaluates to <code>true</code>. We say that the expression is "satisfied" in these states.
</p>
<p class='vspace'>For example, in the property given above:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">"<span class="prismkeyword">init</span>" =&gt; <span class="prismkeyword">P</span>&lt;<span class="prismnum">0.1</span> [ <span class="prismkeyword">F</span>&lt;=<span class="prismnum">100</span> <span class="prismident">num_errors</span> &gt; <span class="prismnum">5</span> ]<br/>
</div></div>
</div>
<p class='vspace'>the expression <code>num_errors &gt; 5</code> is used to identify states of the model where more than 5 errors have occurred.
</p>
<p class='vspace'>It is also common to use <a class='wikilink' href='../ThePRISMLanguage/FormulasAndLabels.html'>labels</a> to identify states in this way, like <code>"terminate"</code> in the example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">1</span> [ <span class="prismkeyword">F</span> "<span class="prismident">terminate</span>" ]<br/>
</div></div>
</div>
<p class='vspace'>Properties can refer to <a class='wikilink' href='../ThePRISMLanguage/FormulasAndLabels.html'>labels</a> either from the model to which the property relates, or included in the same <a class='wikilink' href='../PropertySpecification/PropertiesFiles.html'>properties file</a>.
</p><hr />
<h1>The P Operator</h1>
<p>One of the most important operators in the PRISM property specification language is the <code><strong>P</strong></code> operator, which is used to reason about the probability of an event's occurrence. This operator was originally proposed in the logic PCTL but also features in the other logics supported by PRISM, such as CSL. The <code><strong>P</strong></code> operator is applicable to all three model types: DTMCs, MDPs and CTMCs.
</p>
<p class='vspace'>Informally, the property:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span> <span class="prismident">bound</span> [ <span class="prismident">pathprop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>is true in a state <em>s</em> of a DTMC, MDP or CTMC if
"the probability that path property <code>pathprop</code> is satisfied by the paths from state <em>s</em>
meets the bound <code>bound</code>".
A typical example of a bound would be:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;<span class="prismnum">0.98</span> [ <span class="prismident">pathprop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which means: "the probability that <code>pathprop</code> is satisfied by the paths from state <em>s</em> is greater than 0.98". More precisely, <code>bound</code> can be any of <code>&gt;=p</code>, <code>&gt;p</code>, <code>&lt;=p</code> or <code>&lt;p</code>,
where <code>p</code> is a PRISM language expression evaluating to a double in the range [0,1].
</p>
<p class='vspace'>The types of path property supported by PRISM and their semantics are discussed below.
PRISM also supports <em>quantitative</em> properties of the form <code><strong>P</strong>=?</code> which are covered <a class='wikilink' href='../PropertySpecification/QuantitativeProperties.html'>later</a> in this section.
</p>
<div class='vspace'></div><h3>MDPs</h3>
<p>For MDPs, some additional clarifications are necessary.
Whereas for DTMCs and CTMCs, probability measures over paths are well defined
(see e.g. [<a class='wikilink' href='References.html#KSK66'>KSK66</a>] and [<a class='wikilink' href='References.html#BKH99'>BKH99</a>], respectively),
for MDPs a probability measure can only be feasibly defined once all nondeterminism has been removed.
Hence, the actual meaning of the property
<code>P bound [ pathprop ]</code>
for an MDP is taken to be 
"the probability that <code>pathprop</code> is satisfied by the paths from state <em>s</em>
meets the bound <code>bound</code> for <em>all possible resolutions of nondeterminism</em>".
This means that, for an MDP, properties using the <code><strong>P</strong></code> operator actually reason about the
<em>minimum</em> or <em>maximum</em> probability, over all possible resolutions of nondeterminism,
that a certain type of behaviour is observed.
This depends on the bound attached to the <code><strong>P</strong></code> operator:
a lower bound (<code>&gt;</code> or <code>&gt;=</code>) relates to minimum probabilities
and an upper bound (<code>&lt;</code> or <code>&lt;=</code>) to maximum probabilities.
</p>
<div class='vspace'></div><h3>Path properties</h3>
<p>PRISM supports a wide range of path properties that can be used with the <code><strong>P</strong></code> operator.
A path property is a formula that evaluates to either true or false for a single path in a model.
Here, we review some of the simpler properties that feature a single <em>temporal operator</em>,
as used for example in the logics PCTL and CSL. Later, we briefly describe how PRISM also supports more complex LTL-style path properties.
</p>
<p class='vspace'>The basic different types of path property that can be used inside the <code><strong>P</strong></code> operator are:
</p>
<div class='vspace'></div><ul><li><code><strong>X</strong></code> : "ne<strong>x</strong>t"
</li><li><code><strong>U</strong></code> : "<strong>u</strong>ntil"
</li><li><code><strong>F</strong></code> : "eventually" (sometimes called "<strong>f</strong>uture")
</li><li><code><strong>G</strong></code> : "always" (sometimes called "<strong>g</strong>lobally")
</li><li><code><strong>W</strong></code> : "<strong>w</strong>eak until"
</li><li><code><strong>R</strong></code> : "<strong>r</strong>elease"
</li></ul><p class='vspace'>In the following sections, we describe each of these <em>temporal operators</em>. We then discuss the (optional) use of time bounds with these operators. Finally, we also discuss LTL-style path properties.
</p>
<div class='vspace'></div><h3>"Next" path properties</h3>
<p>The property <code><strong>X</strong> prop</code> is true for a path if <code>prop</code> is true in its second state,
An example of this type of property, used inside a <code><strong>P</strong></code> operator, is:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&lt;<span class="prismnum">0.01</span> [ <span class="prismkeyword">X</span> <span class="prismident">y</span>=<span class="prismnum">1</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which is true in a state if "the probability of the expression <code>y=1</code> being true in the next state is less than 0.01".
</p>
<div class='vspace'></div><h3>"Until" path properties</h3>
<p>The property <code>prop1 <strong>U</strong> prop2</code> is true for a path if
<code>prop2</code> is true in some state of the path and <code>prop1</code> is true in all preceding states.
A simple example of this would be:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;<span class="prismnum">0.5</span> [ <span class="prismident">z</span>&lt;<span class="prismnum">2</span> <span class="prismkeyword">U</span> <span class="prismident">z</span>=<span class="prismnum">2</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which is true in a state if "the probability that <code>z</code> is eventually equal to 2, and that <code>z</code> remains less than 2 up until that point, is greater than 0.5".
</p>
<div class='vspace'></div><h3>"Eventually" path properties</h3>
<p>The property <code><strong>F</strong> prop</code> is true for a path if <code>prop</code> eventually becomes true at some point along the path. The <code><strong>F</strong></code> operator is in fact a special case of the <code><strong>U</strong></code> operator (you will often see <code> <strong>F</strong> prop</code> written as <code><strong>true</strong> <strong>U</strong> prop</code>). A simple example is:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&lt;<span class="prismnum">0.1</span> [ <span class="prismkeyword">F</span> <span class="prismident">z</span>&gt;<span class="prismnum">2</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which is true in a state if "the probability that <code>z</code> is eventually greater than 2is less than 0.1".
</p>
<div class='vspace'></div><h3>"Globally" path properties</h3>
<p>Whereas the <code><strong>F</strong></code> operator is used for "reachability" properties, <code><strong>G</strong></code> represents "invariance". The property <code><strong>G</strong> prop</code> is true of a path if <code>prop</code> remains true at all states along the path. Thus, for example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.99</span> [ <span class="prismkeyword">G</span> <span class="prismident">z</span>&lt;<span class="prismnum">10</span> ]<br/>
</div></div>
</div>
<p class='vspace'>states that, with probability at least 0.99, <code>z</code> never exceeds 10.
</p>
<div class='vspace'></div><h3>"Weak until" and "release" path properties</h3>
<p>Like <code><strong>F</strong></code> and <code><strong>G</strong></code>, the operators <code><strong>W</strong></code> and <code><strong>R</strong></code> are derivable from other temporal operators.
</p>
<p class='vspace'>Weak until (<code>a <strong>W</strong> b</code>), which is equivalent to <code>(a <strong>U</strong> b) | <strong>G</strong> a</code>, requires that <code>a</code> remains true until <code>b</code> becomes true, but does not require that <code>b</code> ever does becomes true (i.e. <code>a</code> remains true forever). For example, a weak form of the until example used above is:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;<span class="prismnum">0.5</span> [ <span class="prismident">z</span>&lt;<span class="prismnum">2</span> <span class="prismkeyword">U</span> <span class="prismident">z</span>=<span class="prismnum">2</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which states that, with probability greater than 0.5, either <code>z</code> is always less than 2, or it is less than 2 until the point where <code>z</code> is 2.
</p>
<p class='vspace'>Release (<code>a <strong>R</strong> b</code>),  which is equivalent to <code>!(!a U !b)</code>, informally means that <code>b</code> is true until <code>a</code> becomes true, or <code>b</code> is true forever.
</p>
<div class='vspace'></div><h3>"Bounded" variants of path properties</h3>
<p>All of the temporal operators given above, with the exception of <code><strong>X</strong></code>, have "bounded" variants, where an additional time bound is imposed on the property being satisfied. Since in DTMCs and MDPs, time progresses in discrete steps, whereas CTMCs model real (continuous) time,
we treat these two cases separately for this operator.
</p>
<p class='vspace'>For a DTMC or MDP, the time interval specification must be of the form "<code>&lt;=t</code>" where <code>t</code> is a PRISM expression evaluating to a non-negative integer. A bounded until property <code>prop1 <strong>U</strong>&lt;=t prop2</code>, for example, is satisfied along a path if <code>prop2</code> becomes true within <code>t</code> steps and <code>prop1</code> is true in all states before that point.
A typical example of this would be:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.98</span> [ <span class="prismident">y</span>&lt;<span class="prismnum">4</span> <span class="prismkeyword">U</span>&lt;=<span class="prismnum">7</span> <span class="prismident">y</span>=<span class="prismnum">4</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which is true in a state if "the probability of <code>y</code> first exceeding 3 within 7 time steps is greater than or equal to 0.98". Similarly:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.98</span> [ <span class="prismkeyword">F</span>&lt;=<span class="prismnum">7</span> <span class="prismident">y</span>=<span class="prismnum">4</span> ]<br/>
</div></div>
</div>
<p class='vspace'>is true in a state if "the probability of <code>y</code> being equal to 4 within 7 time steps is greater than or equal to 0.98" and:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.98</span> [ <span class="prismkeyword">G</span>&lt;=<span class="prismnum">7</span> <span class="prismident">y</span>=<span class="prismnum">4</span> ]<br/>
</div></div>
</div>
<p class='vspace'>is true if the probability of <code>y</code> staying equal to 4 for 7 time steps is at least 0.98.
</p>
<p class='vspace'>The time bound can be an arbitrary (constant) expression,
but note that you may need to bracket it,
as in the following example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.98</span> [ <span class="prismkeyword">G</span>&lt;=(<span class="prismnum">2</span>*<span class="prismident">k</span>+<span class="prismnum">1</span>) <span class="prismident">y</span>=<span class="prismnum">4</span> ]<br/>
</div></div>
</div>
<p class='vspace'>In the context of a CTMC, the time interval specification <code>time</code> can take any of the three forms: <code>&gt;=t</code>, <code>&lt;=t</code> or <code>[t1,t2]</code>, where <code>t</code>, <code>t1</code> and <code>t2</code> are PRISM expressions evaluating to a non-negative doubles, and <code>t1</code> is no greater than <code>t2</code>. In each case, <code>time</code> defines an interval of real values in which the path property must be true.
</p>
<p class='vspace'>For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.25</span> [ <span class="prismident">y</span>&lt;=<span class="prismnum">1</span> <span class="prismkeyword">U</span>&lt;=<span class="prismnum">6.5</span> <span class="prismident">y</span>&gt;<span class="prismnum">1</span> ]<br/>
</div></div>
</div>
<p class='vspace'>means that the probability of <code>y</code> being greater than 1 within 6.5 time-units (and remaining less than or equal to 1 at all preceding time-points) is at least 0.25.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&lt;<span class="prismnum">0.4</span> [ <span class="prismkeyword">F</span>&gt;=<span class="prismnum">5.5</span> <span class="prismident">y</span>&gt;<span class="prismnum">1</span> ]<br/>
</div></div>
</div>
<p class='vspace'>states that the probability of <code>y</code> exceeding 1 at some point after 5.5 time-units have elapsed is less than 0.4, and:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;<span class="prismnum">0</span> [ <span class="prismkeyword">G</span>[<span class="prismnum">5.5</span>,<span class="prismnum">6.5</span>] <span class="prismident">y</span>&gt;<span class="prismnum">1</span> ]<br/>
</div></div>
</div>
<p class='vspace'>says that the probability that <code>y</code> exceeds 1 for the whole time interval <code>[5.5,6.5]</code> is greater than zero".
</p>
<div class='vspace'></div><h3>Transient probabilities</h3>
<p>We can also use the bounded <code><strong>F</strong></code> operator to refer to a single time instant, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&lt;<span class="prismnum">0.01</span> [ <span class="prismkeyword">F</span>[<span class="prismnum">10</span>,<span class="prismnum">10</span>] <span class="prismident">y</span>=<span class="prismnum">6</span> ]<br/>
</div></div>
</div>
<p class='vspace'>refers to the probability of <code>y</code> being 6 at time instant 10.
</p>
<div class='vspace'></div><h3>LTL-style path properties</h3>
<p>PRISM also supports probabilistic model checking of the temporal logic LTL (and, in fact, PCTL*). LTL provides a richer set of path properties for use with the <code><strong>P</strong></code> operator, by permitting temporal operators to be combined. Here are a few examples of properties expressible using this functionality:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;<span class="prismnum">0.99</span> [ <span class="prismkeyword">F</span> ( "<span class="prismident">request</span>" &amp; (<span class="prismkeyword">X</span> "<span class="prismident">ack</span>") ) ]<br/>
</div></div>
</div>
<p class='vspace'>"with probability greater than 0.99, a request is eventually received, followed immediately by an acknowledgement"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;=<span class="prismnum">1</span> [ <span class="prismkeyword">G</span> <span class="prismkeyword">F</span> "<span class="prismident">send</span>" ]<br/>
</div></div>
</div>
<p class='vspace'>"a message is sent infinitely often with probability 1"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&lt;<span class="prismnum">0.01</span> [ <span class="prismkeyword">F</span> <span class="prismkeyword">G</span> ("<span class="prismident">error</span>" &amp; !"<span class="prismident">repair</span>") ]<br/>
</div></div>
</div>
<p class='vspace'>"the probability of an error occurring that is never repaired is less than 0.01"
occurs?
</p><hr />
<h1>Quantitative Properties</h1>
<p>It is very often useful to take a <em>quantitative</em> approach to probabilistic model checking, computing the actual probability that some behaviour of a model is observed,
rather than just verifying whether or not the probability is above or below a given bound.
Hence, PRISM allows the <code><strong>P</strong></code> operator to take the following form:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ <span class="prismident">pathprop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>These properties return a numerical rather than a Boolean value.
The <a class='wikilink' href='../PropertySpecification/TheSOperator.html'>S</a> and <a class='wikilink' href='../PropertySpecification/Reward-basedProperties.html'>R</a> operators, discussed later, can also be used in this way.
</p>
<p class='vspace'>Note that the probability bound on a <code><strong>P</strong></code> operator can only be replaced with <code>=?</code>
if it is the outermost operator of the property in which it appears; otherwise the semantics are not well defined. Note also that, for MDPs, the situation is slightly more complex. Probabilities for an MDP can only be computed once the nondeterminism has been resolved. Hence, PRISM actually computes either the <em>minimum</em> or <em>maximum</em> probability of a path property being satisfied, quantifying over all possible resolutions (i.e. the best and worst cases).  Therefore, for MDPs we have two possible types of property:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">Pmin</span>=? [ <span class="prismident">pathprop</span> ]<br/>
<span class="prismkeyword">Pmax</span>=? [ <span class="prismident">pathprop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which return the minimum and maximum probabilities, respectively.
</p>
<p class='vspace'>All of these operators return a single numerical value.
In the simplest case, where the model being verified has a single initial state,
the numerical value returned is the one corresponding to that state.
Hence, for example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span> <span class="prismident">x</span>=<span class="prismnum">5</span>&amp;<span class="prismident">y</span>=<span class="prismnum">5</span> ]<br/>
</div></div>
</div>
<p class='vspace'>returns the probability of, from the initial state, reaching a state satisfying <code>x=5&amp;y=5</code>.
It is also possible, however, to obtain the probability for an arbitrary state,
by specifying an atomic proposition, true only in that state, inside braces (<code>{...}</code>) before the closing <code>]</code> bracket.
This is known as a <em>filter</em>.
For example, if the model contains two variables, <code><strong>X</strong></code> and <code>y</code>, then:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span> <span class="prismident">x</span>=<span class="prismnum">5</span>&amp;<span class="prismident">y</span>=<span class="prismnum">5</span> {<span class="prismident">x</span>=<span class="prismnum">1</span>&amp;<span class="prismident">y</span>=<span class="prismnum">2</span>} ]<br/>
</div></div>
</div>
<p class='vspace'>returns the probability of, from the state <code>(1,2)</code> (i.e. <code>x=1</code> and <code>y=2</code>),
reaching a state satisfying <code>x=5&amp;y=5</code>.
It is possible of course that the expression in the filter satisfies more than one state.
If this the case, by default the first such state (lexicographically) is chosen.
In this situation, PRISM will display a warning to notify you that the expression in the filter matched multiple states
and will display what the first matching state is.
The same approach is taken in the situation where no filter is given
but the model contains multiple initial states.
In this case, the numerical result obtained is for the first (lexicographically speaking) of the set of initial states.
Note that if the expression in the filter is not satisfied by any states of the model,
an error is reported.
</p>
<p class='vspace'>It is also possible to possible to request either the minimum and maximum value from a set of values.
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span> <span class="prismident">x</span>=<span class="prismnum">5</span>&amp;<span class="prismident">y</span>=<span class="prismnum">5</span> {<span class="prismident">y</span>=<span class="prismnum">2</span>}{<span class="prismkeyword">min</span>} ]<br/>
<span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span> <span class="prismident">x</span>=<span class="prismnum">5</span>&amp;<span class="prismident">y</span>=<span class="prismnum">5</span> {<span class="prismident">y</span>=<span class="prismnum">2</span>}{<span class="prismkeyword">max</span>} ]<br/>
</div></div>
</div>
<p class='vspace'>return the minimum and maximum probability, respectively,
of reaching a state satisfying <code>x=5&amp;y=5</code> from all the states satisfying <code>y=2</code>.
In addition, PRISM will report the states of the model in which the minimum or maximum probability is attained.
You can in fact also request that both the minimum and maximum value are computed simultaneously using,
for example, <code>{y=2}{min}{max}</code>. In this case, both values will be reported, but the actual
return value of the property will be the minimum value.
</p>
<p class='vspace'>Finally, note that filters can also be used for classical (bounded) <code><strong>P</strong></code> properties.
This has no bearing on the result of model checking a property;
it simply causes the probabilities (where non-zero) for all states satisfying the expression in the filter to be printed during model checking (in the log, if using the GUI, or to the screen, if using the command-line).
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>&gt;<span class="prismnum">0.5</span> [ <span class="prismkeyword">F</span> <span class="prismident">x</span>=<span class="prismnum">5</span>&amp;<span class="prismident">y</span>=<span class="prismnum">5</span> {<span class="prismident">y</span>=<span class="prismnum">2</span>} ]<br/>
</div></div>
</div>
<p class='vspace'>will return a Boolean value, depending whether the property is true in all states of the model or not,
but the probability (where non-zero) of path property <code>F x=5&amp;y=5</code> being satisfied will be displayed for all states where <code>y=2</code>.
</p><hr />
<h1>The S Operator</h1>
<p>The <code><strong>S</strong></code> operator is used to reason about the <em>steady-state</em> behaviour of a model,
i.e. its behaviour in the <em>long-run</em> or <em>equilibrium</em>.
Although this could in principle relate to all three model types,
PRISM currently only provides support for DTMCs and CTMCs.
The definition of steady-state (long-run) probabilities for finite DTMCS and CTMCs is well defined (see e.g. [<a class='wikilink' href='References.html#Ste94'>Ste94</a>]).
Informally, the property:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">S</span> <span class="prismident">bound</span> [ <span class="prismident">prop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>is true in a state <em>s</em> of a DTMC or CTMC if
"starting from <em>s</em>, the steady-state (long-run) probability of being in a state which satisfies the (Boolean-valued) PRISM property <code>prop</code>, meets the bound <code>bound</code>".
A typical example of this type of property would be:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">S</span>&lt;<span class="prismnum">0.05</span> [ <span class="prismident">queue_size</span> / <span class="prismident">max_size</span> &gt; <span class="prismnum">0.75</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which means: "the long-run probability of the queue being more than 75% full is less than 0.05".
</p>
<p class='vspace'>Like the <code><strong>P</strong></code> operator, the <code><strong>S</strong></code> operator can be used in a <a class='wikilink' href='../PropertySpecification/QuantitativeProperties.html'>quantitative</a> form, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">S</span>=? [ <span class="prismident">queue_size</span> / <span class="prismident">max_size</span> &gt; <span class="prismnum">0.75</span> ]<br/>
</div></div>
</div>
<p class='vspace'>including the use of <a class='wikilink' href='../PropertySpecification/QuantitativeProperties.html'>filters</a>.
</p><hr />
<h1>Reward-based Properties</h1>
<p>PRISM models can be augmented with information about <a class='wikilink' href='../ThePRISMLanguage/CostsAndRewards.html'>rewards</a> (or, equivalently, costs).
The tool can analyse properties which relate to the <em>expected values</em> of these rewards.
This is achieved using the <code><strong>R</strong></code> operator, which works in a similar fashion to the
<code><strong>P</strong></code> and <code><strong>S</strong></code> operators, and can be used either in a Boolean-valued query, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span> <span class="prismident">bound</span> [ <span class="prismident">rewardprop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>where <code>bound</code> takes the form <code>&lt;r</code>, <code>&lt;=r</code>, <code>&gt;r</code> or <code>&gt;=r</code> for an expression <code>r</code> evaluating to a non-negative double,
or a real-valued query, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span> <span class="prismident">query</span> [ <span class="prismident">rewardprop</span> ]<br/>
</div></div>
</div>
<p class='vspace'>where <code>query</code> is <code>=?</code> for a DTMC or CTMC, and <code>min=?</code> or <code>max=?</code> for MDPs.
In the latter case, <a class='wikilink' href='../PropertySpecification/QuantitativeProperties.html'>filters</a> can be used, as for the <code><strong>P</strong></code> and <code><strong>S</strong></code> operators.
</p>
<p class='vspace'>Informally, "<code><strong>R</strong> bound [ rewardprop ]</code>" is true in a state of a model if
"the expected reward associated with <code>rewardprop</code> of the model when starting from that state''
meets the bound <code>bound</code> and "<code><strong>R</strong> query [ rewardprop ]</code>"  returns the actual expected reward value.
</p>
<p class='vspace'>There are four different types of reward properties, namely:
</p>
<div class='vspace'></div><ul><li>"reachability reward": <code><strong>F</strong> prop</code>
</li><li>"cumulative reward" : <code><strong>C</strong>&lt;=t</code>
</li><li>"instantaneous reward" : <code><strong>I</strong>=t</code>
</li><li>"steady-state reward" : <code><strong>S</strong></code>.
</li></ul><p class='vspace'>Below, we consider each of these cases in turn.
The descriptions here are kept relatively informal.
For precise definitions (in the case of DTMCs and CTMCs), see [<a class='wikilink' href='References.html#KNP07a'>KNP07a</a>].
</p>
<div class='vspace'></div><h3>"Reachability reward" properties</h3>
<p>"Reachability reward" properties associate a reward with each path of a model.
More specifically, they refer to the reward accumulated along a path until a certain point is reached.
The manner in which rewards are accumulated depends on the model type.
For DTMCs and MDPs, the total reward for a path is the sum of the state rewards for each state along the path
plus the sum of the transition rewards for each transition between these states.
The situation for CTMCs is similar, except that the state reward assigned to each state
of the model is interpreted as the <em>rate</em> at which rewards are accumulated in that state,
i.e. if <em>t</em> time units are spent in a state with state reward <em>r</em>,
the reward accumulated in that state is <em>r</em> x <em>t</em>.
Hence, the total reward for a path in a CTMC is the sum of these products for each state along the path
plus the sum of the transition rewards for each transition between these states.
</p>
<p class='vspace'>The reward property "<code>F prop</code>" corresponds to the reward cumulated along a path
until a state satisfying property <code>prop</code> is reached,
where rewards are cumulated as described above.
State rewards for the <code>prop</code>-satisfying state reached are not included in the cumulated value.
In the case where the probability of reaching a state satisfying <code>prop</code> is less than 1, the reward is equal to infinity.
</p>
<p class='vspace'>A common application of this type of property is the case when the rewards associated with the model correspond to time.
One can then state, for example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span>&lt;=<span class="prismnum">9.5</span> [ <span class="prismkeyword">F</span> <span class="prismident">z</span>=<span class="prismnum">2</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which is true in a state <em>s</em> if "the expected time taken to reach, from <em>s</em>, a state where <code>z</code> equals 2 is less than or equal to 9.5".
</p>
<div class='vspace'></div><h3>"Cumulative reward" properties</h3>
<p>"Cumulative reward" properties also associate a reward with each path of a model,
but only up to a given time bound.
The property <code>C&lt;=t</code> corresponds to the reward cumulated along a path
until <code>t</code> time units have elapsed.
For DTMCs and MDPs, the bound <code>t</code> must evaluate to an integer;
for CTMCs, it can evaluate to double.
State and transition rewards along a path are cumulated exactly as described in the previous section.
</p>
<p class='vspace'>A typical application of this type of property is the following.
Consider a model of a disk-drive controller which includes a queue of incoming disk requests.
If we assign a reward of 1 to each transition of the model
corresponding to the situation where an incoming request is lost because the queue is full,
then the property:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span>=? [ <span class="prismkeyword">C</span>&lt;=<span class="prismnum">15.5</span> ]<br/>
</div></div>
</div>
<p class='vspace'>would return, for a given state of the model,
"the expected number of lost requests within 15.5 time units of operation".
</p>
<div class='vspace'></div><h3>"Instantaneous reward" properties</h3>
<p>"Instantaneous reward" properties refer to the reward of a model at a particular instant in time.
The reward property <code>I=t</code> associates with a path the reward in the state 
of that path when exactly <code>t</code> time units have elapsed.
For DTMCs and MDPs, the bound <code>t</code> must evaluate to an integer;
for CTMCs, it can evaluate to double.
</p>
<p class='vspace'>Returning to our example from the previous section of a model for a disk-request queue in a disk-drive controller,
consider the case where the rewards assigned to each state of the model give the current size of the queue in that state.
Then, the following property:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span>&lt;<span class="prismnum">4.4</span> [ <span class="prismkeyword">I</span>=<span class="prismnum">100</span> ]<br/>
</div></div>
</div>
<p class='vspace'>would be true in a state <em>s</em> of the model if
"starting from <em>s</em>, the expected queue size exactly 100 time units later is less than 4.4".
Note that, for this type of reward property, state rewards for CTMCs do not have to refer to rates;
they can refer to any instantaneous measure of interest for a state.
</p>
<div class='vspace'></div><h3>"Steady-state reward" properties</h3>
<p>Unlike the previous three types of property,
"steady-state reward" properties relate not to paths, but rather to the reward in the long-run.
A typical application of this type of property would be, in the case where
the rewards associated with the model correspond to power consumption, the property:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span>&lt;=<span class="prismnum">0.7</span> [ <span class="prismkeyword">S</span> ]<br/>
</div></div>
</div>
<p class='vspace'>which is true in a state <em>s</em> if "starting from <em>s</em>, the long-run average power consumption is less than 0.7".
</p>
<div class='vspace'></div><h3>Which reward structure?</h3>
<p>In the case where a PRISM model has multiple <a class='wikilink' href='../ThePRISMLanguage/CostsAndRewards.html'>reward structures</a> you may need to specify which reward structure your property refers to. This is done by placing the information in braces (<code>{}</code>) after the <code>R</code> operator. You can do so either using the name assigned to a reward structure (if any) or using the index (where <code>1</code> means the first rewards structure in the PRISM model file, <code>2</code> the second, etc.). Examples are:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span>{"<span class="prismident">num_failures</span>"}=? [ <span class="prismkeyword">C</span>&lt;=<span class="prismnum">10.0</span> ]<br/>
<span class="prismkeyword">R</span>{"<span class="prismident">time</span>"}=? [ <span class="prismkeyword">F</span> <span class="prismident">step</span>=<span class="prismident">final</span> ]<br/>
<span class="prismkeyword">R</span>{<span class="prismnum">2</span>}=? [ <span class="prismkeyword">F</span> <span class="prismident">step</span>=<span class="prismident">final</span> ]<br/>
</div></div>
</div>
<p class='vspace'>Note that when using an index to specify the reward structure, you can actually put any expression that evaluates to an integer. This allows you to, for example, write a property of the form <code>R{c}=?[...]</code> where <code>c</code> is an undefined integer constant. You can then vary the value of <code>c</code> in an experiment and compute values for several different reward structures at once.
</p>
<p class='vspace'>If you don't specify a reward structure to the <code>R</code> operator, by default, the first one in the model file is used.
</p>
<div class='vspace'></div><h3>Availability</h3>
<p>There are currently a few restrictions on the model checking <a class='wikilink' href='../ConfiguringPRISM/ComputationEngines.html'>engines</a> that can be used for some reward properties. The following table summarises the currently availability, where S, M and H denote the "sparse", "MTBDD" and "hybrid" engines, respectively.
</p>
<div class='vspace'></div>
<table border='1' ><tr ><td >&nbsp;</td><td  align='center'><code><strong>F</strong></code></td><td  align='center'><code><strong>C</strong>&lt;=t</code></td><td  align='left'><code><strong>I</strong>=t</code></td><td  align='right'><code><strong>S</strong></code></td></tr>
<tr ><td  align='center'><strong>DTMCs</strong></td><td  align='center'>SMH</td><td  align='center'>SMH</td><td  align='center'>SMH</td><td  align='right'>SMH</td></tr>
<tr ><td  align='center'><strong>CTMCs</strong></td><td  align='center'>SMH</td><td  align='center'>SMH</td><td  align='center'>SMH</td><td  align='right'>SMH</td></tr>
<tr ><td  align='center'><strong>MDPs</strong></td><td  align='center'>SM-</td><td  align='center'>---</td><td  align='center'>SM-</td><td  align='right'>n/a</td></tr>
</table><hr />
<h1>Syntax And Semantics</h1>
<p>The three principal operators of the PRISM property specification language, namely <code><strong>P</strong></code>, <code><strong>S</strong></code> and <code><strong>R</strong></code>, can be combined into any valid, well-typed PRISM <a class='wikilink' href='../ThePRISMLanguage/Expressions.html'>expression</a>. This mean that any of the following operators can be used:
</p>
<div class='vspace'></div><ul><li><code>-</code> (unary minus)
</li><li><code>*</code>, <code>/</code> (multiplication, division)
</li><li><code>+</code>, <code>-</code> (addition, subtraction)
</li><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code> (relational operators)
</li><li><code>=</code>, <code>!=</code> (equality operators)
</li><li><code>!</code> (negation)
</li><li><code>&amp;</code> (conjunction)
</li><li><code>|</code> (disjunction)
</li><li><code>=&gt;</code> (implication)
</li><li><code>?</code> (condition evaluation: <code>condition ? a : b</code> means "if <code>condition</code> is true then <code>a</code> else <code>b</code>")
</li></ul><p class='vspace'>Logical operators can be used, for example, to specify any property expressible in logics such as PCTL and CSL, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">"<span class="prismident">no_error</span>" =&gt; <span class="prismkeyword">P</span>&lt;<span class="prismnum">0.1</span> [ <span class="prismkeyword">F</span> ("<span class="prismident">error1</span>" | "<span class="prismident">error2</span>") ]<br/>
</div></div>
</div>
<p class='vspace'>Other operators can also be used to derive various arithmetic expressions such as:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span>[<span class="prismnum">3600</span>,<span class="prismnum">7200</span>] <span class="prismident">oper</span> ]<br/>
</div></div>
</div>
<p class='vspace'>"the probability that the system is <strong>not</strong> operational at any point during the second hour of operation"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">R</span>{"<span class="prismident">oper</span>"}=? [ <span class="prismkeyword">C</span>&lt;=<span class="prismident">t</span> ] / <span class="prismident">t</span><br/>
</div></div>
</div>
<p class='vspace'>"the expected fraction of time that the system is available (i.e. the expected interval availability) in the time interval [0, t]"
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span> <span class="prismident">fail_A</span> ] / <span class="prismkeyword">P</span>=? [ <span class="prismkeyword">F</span> <span class="prismident">any_fail</span> ]<br/>
</div></div>
</div>
<p class='vspace'>"the (conditional) probability that component A eventually fails, given
that at least one component fails"
</p>
<div class='vspace'></div><h3>Semantics</h3>
<p>We omit a formal presentation of the semantics of the PRISM property language. The semantics of the probabilistic temporal logics that the language incorporates can be found from a variety of sources. See for example the pointers given in the <a class='urllink' href='http://www.prismmodelchecker.org/about.php'>About</a> and <a class='urllink' href='http://www.prismmodelchecker.org/doc/'>Documentation</a> sections of the PRISM website.
</p>
<p class='vspace'>It is worth, however, clarifying a few points specific to PRISM. A property is evaluated with respect to a particular state of a model. Depending on the type of the property, this value may either be a Boolean, an integer or a double. When analysing a property of a model, though, PRISM actually determines the value for all states of the model. Furthermore, the final value that PRISM returns as the result of model checking depends on the model type.
</p>
<p class='vspace'>For Boolean properties, such as those conforming to the classical syntax of PCTL, CSL, etc., PRISM returns a value of <code>true</code> if the property is true for <strong>all</strong> states of the model. To check if a property is satisfied in some subset of states, for example just the initial states, properties can be prefixed with an implication, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">"<span class="prismkeyword">init</span>" =&gt; <span class="prismkeyword">P</span>&gt;=<span class="prismnum">1</span> [ <span class="prismkeyword">F</span> <span class="prismident">leader_elected</span>=<span class="prismkeyword">true</span> ]<br/>
</div></div>
</div>
<p class='vspace'>For numeric properties, typically a single value (for a single state) is required. The default behaviour of PRISM is to return the value for the initial state of the model. This issue was discussed in more depth in the the <a class='wikilink' href='../PropertySpecification/QuantitativeProperties.html'>Quantitative Properties</a> section.
</p>
<div class='vspace'></div><hr />
<h1>Properties Files</h1>
<p>Files containing properties to be analysed by PRISM can also contain constants, as is the case for model files.
These are defined in identical fashion, for example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">k</span> = <span class="prismnum">7</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">T</span> = <span class="prismnum">9.5</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">p</span> = <span class="prismnum">0.01</span>;<br/>
<br/>
<span class="prismkeyword">P</span>&lt;<span class="prismident">p</span> [ <span class="prismkeyword">true</span> <span class="prismkeyword">U</span>&lt;=<span class="prismident">T</span> <span class="prismident">x</span>=<span class="prismident">k</span> ]<br/>
</div></div>
</div>
<p class='vspace'>As before, these constants can actually be left undefined and then later
assigned either a single value or a range of values using <a class='wikilink' href='../RunningPRISM/Experiments.html'>experiments</a>.
</p>
<p class='vspace'>In fact, probability bounds for the <code><strong>P</strong></code> or <code><strong>S</strong></code> operators (like <code><strong>P</strong></code> above)
and upper or lower bounds for the <code><strong>U</strong></code> operator (like <code> T</code> above)
can be arbitrary expressions, provided they are constant.
Furthermore, expressions in the properties file can also refer to constants previous defined in the model file.
</p>
<p class='vspace'>Another feature of properties files is <em>labels</em>. These are a way of defining sets of states that will be referred to in properties (they correspond to <em>atomic propositions</em> in a temporal logic setting). As described <a class='wikilink' href='../ThePRISMLanguage/FormulasAndLabels.html'>earlier</a>, labels can be defined in either model files or property files.
</p>
<p class='vspace'>Labels are defined using the keyword <code><strong>label</strong></code>, followed by a name (identifier) in double quotes, and then an expression which evaluates to a Boolean. Definition and usage of formulas are illustrated in the following example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">label</span> "<span class="prismident">safe</span>" = <span class="prismident">temp</span>&lt;=<span class="prismnum">100</span> | <span class="prismident">alarm</span>=<span class="prismkeyword">true</span>;<br/>
<span class="prismkeyword">label</span> "<span class="prismident">fail</span>" = <span class="prismident">temp</span>&gt;<span class="prismnum">100</span> &amp; <span class="prismident">alarm</span>=<span class="prismkeyword">false</span>;<br/>
<br/>
<span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.99</span> [ "<span class="prismident">safe</span>" <span class="prismkeyword">U</span> "<span class="prismident">fail</span>" ]<br/>
</div></div>
</div>
<p class='vspace'>Two special cases are the <code>"init"</code> and <code>"deadlock"</code> labels which are always defined.
These are true in initial states of the model and states where deadlocks were found (and fixed by adding self-loops), respectively.
The former is useful if you only wish to to check whether a property is true in the initial states, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">"<span class="prismkeyword">init</span>" =&gt; <span class="prismkeyword">P</span>&gt;=<span class="prismnum">0.99</span> [ "<span class="prismident">safe</span>" <span class="prismkeyword">U</span> "<span class="prismident">fail</span>" ]<br/>
</div></div>
</div>
<p class='vspace'>A PRISM properties file can contain any number of properties.
Like model files, they can also include any amount of white space (spaces, tabs, new lines, etc.) and C-style comments, which are both ignored.
By convention, files are given the extension <code>.pctl</code> for properties of DTMCs and MDPs
and extension <code>.csl</code> for properties of CTMCs.
<br /><br />
</p><hr />
<div class='vspace'></div><h1><span class='big'>Running PRISM</span></h1>
<hr />
<h1>Starting PRISM</h1>
<p>There are two versions of PRISM, one based on a graphical user interface (GUI),
the other based on a command line interface. Both use the same underlying model checker.
The latter is useful for running large batches of jobs, leaving long-running model checking tasks in the background,
or simply for running the tool quickly and easily once you are familiar with its operation.
Assuming that the <code>bin</code> directory of your PRISM distribution is in your path,
the GUI version can be started by typing <code>xprism</code> and the command-line version by typing <code>prism</code>
(typically with several arguments and switches).
Below are screenshots of the PRISM GUI and
the command-line version running.
</p>
<div class='vspace'></div><div> <a class='urllink' href='../uploads/gui1.gif'><img width='500' src='../uploads/gui1.gif' alt='' title='' /></a><br /><strong>The PRISM GUI</strong></div>
<div class='vspace'></div><div> <a class='urllink' href='../uploads/gui2.gif'><img width='500' src='../uploads/gui2.gif' alt='' title='' /></a><br /><strong>The PRISM GUI</strong></div>
<div class='vspace'></div><div> <a class='urllink' href='../uploads/cl.gif'><img width='500' src='../uploads/cl.gif' alt='' title='' /></a><br /><strong>The Command-Line</strong></div>
<hr />
<h1>Loading And Building a Model</h1>
<p>Use of PRISM typically starts with the construction of a probabilistic model,
i.e. the conversion of a description in the PRISM language to an MDP, DTMC or CTMC, as appropriate.
During this process, PRISM computes the set of states in the model which are reachable from the initial states
and the transition matrix which represents the model.
There are a selection of sample PRISM model files in the <code>examples</code> directory of the distribution.
From the command-line, simply type:
</p>
<p class='vspace'><code class='escaped'> prism model </code>
</p>
<p class='vspace'>where <code>model</code> is the name of the file containing the model description.
In the GUI, select menu option "Model | Open Model" and choose a file.
The model will be displayed in the editor in the "Model" tab of the GUI window.
The file is parsed upon loading. If there are no errors, information about the modules, variables,
and other components of the model is displayed in the panel to the left and a green tick will be visible.
If there are errors in the file, a red cross will appear instead and the errors will be highlighted in the model editor.
To view details of the error, position the mouse pointer over the source of the error (or over the red cross).
Alternatively, select menu option "Model | Parse Model" and the error message will be displayed in a message box.
Model descriptions can, of course, also be typed from scratch into the GUI's editor.
</p>
<p class='vspace'>Once the file has been parsed successfully, the model can be built by selecting "Model | Build Model". If there are no errors during model construction, the number of states and transitions in the model will be displayed in the bottom left corner of the window.
</p>
<div class='vspace'></div><h3>Deadlocks</h3>
<p>The presence of <em>deadlock states</em> in the model,
i.e. states which are reachable but from which there are no outgoing transitions, constitutes an error. From the GUI, you are offered the opportunity to automatically add self-loops to these states to resolve the situation.
The same can be achieved from the command-line by using the <code>-fixdl</code> switch.
Otherwise, the deadlock states are displayed (in the GUI, they appear in the "Log" tab of the main window). Note that if you choose to fix the deadlocks by adding self-loops, you can determine in which states this occurred by model checking the property <code>"deadlock"</code>. Another useful technique in this situation is to generate a random path in the <a class='wikilink' href='../RunningPRISM/DebuggingModelsWithTheSimulator.html'>simulator</a> in the hope of reaching a deadlock state. This will give you useful information about how the state can be reached.
</p><hr />
<h1>Debugging Models With The Simulator</h1>
<p>PRISM includes a <em>simulator</em>, a tool which can be used to generate sample paths (executions) through a PRISM model. From the GUI, the simulator allows you to explore a model by interactively generating such paths. This is particularly useful for debugging models during development and for running sanity checks on completed models. Paths can also be generated from the command-line.
</p>
<div class='vspace'></div><h3>Generating a path in the GUI</h3>
<p>Once you have loaded a model into the PRISM GUI
(note that it is not necessary to build the model),
select the "Simulator" tab at the bottom of the main window.
You can now start a new path by double-clicking in the bottom half of the window
(or right-clicking and selecting "New path").
If there are undefined constants in the
model (or in any currently loaded properties files) you will be prompted to give values for these. You
can also specify the state from which you wish to generate a path. By default, this is the initial state of
the model.
</p>
<p class='vspace'>The main portion of the user interface (the bottom part) displays a path through the currently loaded model. Initially, this will comprise just a single state. The table above shows the list of available transitions from this state. Double-click one of these to extend the path with this transition. The process can be repeated to extend the path in an interactive fashion. Clicking on any state in the current path shows the transition which was taken at this stage. Click on the final state in the path to continue
extending the path. Alternatively, clicking the "Simulate" button will select a transition randomly (according to the probabilities/rates of the available transitions). By changing the number in the box below this button, you can easily generate random paths of a given length with a single click.
There are also options (in the accompanying drop-down menu) to allow generation of paths up until a particular length or, for CTMCs, in terms of the time taken.
</p>
<p class='vspace'>The figure shows the simulator in action.
</p>
<div class='vspace'></div><div><a class='urllink' href='../uploads/gui-sim.png'><img src='../uploads/gui-sim.png' alt='' title='' /></a><br /><strong>The PRISM GUI: exploring a model using the simulator</strong></div>
<p class='vspace'>It is also possible to:
</p>
<div class='vspace'></div><ul><li>backtrack to an earlier point in a path
</li><li>remove all of the states before some point in a path
</li><li>restart a path from its first state
</li><li>export a path to a text file
</li></ul><p class='vspace'>Notice that the table containing the path displays not just the value of each variable in each
state but also the time spent in that state and any rewards accumulated there. You can configure exactly which columns appear by right-clicking on the path and selecting "Configure view". For rewards (and for CTMC models, for the time-values), you can can opt to display the reward/time for each individual state and/or the cumulative total up until each point in the path.
</p>
<p class='vspace'>At the top-right of the interface, any labels contained in the currently loaded model/properties file are displayed, along with their value in the currently selected state of the path. In addition, the built-in labels <code>"init"</code> and <code>"deadlock"</code> are also included. Selecting a label from the list highlights all states in the current path which satisfy it.
</p>
<p class='vspace'>The other tabs in this panel allow the value of path operators (taken from properties in the current file) to be viewed for the current path, as well as various other statistics.
</p>
<div class='vspace'></div><h3>Path generation from the command-line</h3>
<p>It is also possible to generate random paths through a model using the command-line version of PRISM. This is achieved using the <code>-simpath</code> switch, which requires two arguments, the first describing the path to be generated and the second specifying the file to which the path should be output (as usual, specifying <code>stdout</code> sends output to the terminal). The following examples illustrate the various ways of generating paths in this way:
</p>
<div class='vspace'></div><ul><li><code>prism model.pm -simpath 10 path.txt</code> (a path of 10 steps)
</li><li><code>prism model.pm -simpath time=7.5 path.txt</code> (a path of at most 7.5 time units)
</li><li><code>prism model.pm -simpath deadlock path.txt</code> (a path ending in deadlock)
</li></ul><p class='vspace'>Further options can also be appended to the first parameter. If you are only interested in the changes to certain variables of your model, use the <code>vars=(...)</code> option. For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism model.sm -simpath 10 stdout</span><br/>
<span style="font-style:italic;">...</span><br/>
<span style="font-style:italic;">step a b c time</span><br/>
<span style="font-style:italic;">0 0 0 0 0.0</span><br/>
<span style="font-style:italic;">1 0 1 0 0.016569539535505946</span><br/>
<span style="font-style:italic;">2 0 1 1 0.04999280708731619</span><br/>
<span style="font-style:italic;">3 0 2 1 0.0637472535911344</span><br/>
<span style="font-style:italic;">4 0 2 2 0.243645533565261</span><br/>
<span style="font-style:italic;">5 0 2 3 0.5359625623773467</span><br/>
<span style="font-style:italic;">6 0 3 3 0.7862449420673264</span><br/>
<span style="font-style:italic;">7 1 3 3 0.8749262111456289</span><br/>
<span style="font-style:italic;">8 1 3 4 0.9472785807052686</span><br/>
<span style="font-style:italic;">9 1 3 5 1.040096742715008</span><br/>
<span style="font-style:italic;">10 1 3 6 1.2801655430222152</span><br/>
</div></div>
</div>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism model.sm -simpath '10,vars=(a,b)' stdout</span><br/>
<span style="font-style:italic;">...</span><br/>
<span style="font-style:italic;">step a b time</span><br/>
<span style="font-style:italic;">0 0 0 0.0</span><br/>
<span style="font-style:italic;">1 0 1 0.20115547684708998</span><br/>
<span style="font-style:italic;">5 0 2 0.5822925951221433</span><br/>
<span style="font-style:italic;">7 1 2 0.9559600285257709</span><br/>
<span style="font-style:italic;">8 1 3 1.3395175958850654</span><br/>
<span style="font-style:italic;">10 1 4 1.869013176198441</span><br/>
</div></div>
</div>
<p class='vspace'>Note the use of single quotes around the path description argument to prevent the shell from misinterpreting special characters such as "<code>(</code>".
</p>
<p class='vspace'>You can also use the <code>sep=...</code> option to specify the column separator. Possible values are <code>space</code> (the default), <code>tab</code> and <code>comma</code>. For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism model.sm -simpath '10,vars=(a,b),sep=comma' stdout</span><br/>
<span style="font-style:italic;">...</span><br/>
<span style="font-style:italic;">step,a,b,time</span><br/>
<span style="font-style:italic;">0,0,0,0.0</span><br/>
<span style="font-style:italic;">2,1,0,0.058443536856580006</span><br/>
<span style="font-style:italic;">3,1,1,0.09281024515535738</span><br/>
<span style="font-style:italic;">6,1,2,0.2556555786269585</span><br/>
<span style="font-style:italic;">7,1,3,0.284062896359802</span><br/>
<span style="font-style:italic;">8,1,4,1.1792064236954896</span><br/>
</div></div>
</div>
<p class='vspace'>When generating paths to a deadlock state, additional <code>repeat=...</code> option is available which will construct multiple paths until a deadlock is found. For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism model.sm -simpath 'deadlock,repeat=100' stdout</span><br/>
</div></div>
</div>
<p class='vspace'>By default, the simulator detects deterministic loops in paths (e.g. if a path reaches a state from which there is a just a single self-loop leaving that state) and stops generating the path any further. You can disable this behaviour with the <code>loopcheck=false</code> option. For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism dice.pm -simpath 10 stdout</span><br/>
<span style="font-style:italic;">...</span><br/>
<span style="font-style:italic;">Warning: Deterministic loop detected after 6 steps (use loopcheck=false option to extend path).</span><br/>
<span style="font-style:italic;">step s d state_reward transition_reward</span><br/>
<span style="font-style:italic;">0 0 0 0.0 1.0</span><br/>
<span style="font-style:italic;">1 1 0 0.0 1.0</span><br/>
<span style="font-style:italic;">2 3 0 0.0 1.0</span><br/>
<span style="font-style:italic;">3 1 0 0.0 1.0</span><br/>
<span style="font-style:italic;">4 4 0 0.0 1.0</span><br/>
<span style="font-style:italic;">5 7 3 0.0 0.0</span><br/>
<span style="font-style:italic;">6 7 3 0.0 0.0</span><br/>
</div></div>
</div>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism dice.pm -simpath 10,loopcheck=false stdout</span><br/>
<span style="font-style:italic;">...</span><br/>
<span style="font-style:italic;">step s d state_reward transition_reward</span><br/>
<span style="font-style:italic;">0 0 0 0.0 1.0</span><br/>
<span style="font-style:italic;">1 2 0 0.0 1.0</span><br/>
<span style="font-style:italic;">2 6 0 0.0 1.0</span><br/>
<span style="font-style:italic;">3 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">4 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">5 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">6 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">7 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">8 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">9 7 6 0.0 0.0</span><br/>
<span style="font-style:italic;">10 7 6 0.0 0.0</span><br/>
</div></div>
</div>
<p class='vspace'>One final note: the <code>-simpath</code> switch only generates paths up to the maximum path length setting of the simulator (the default is 10,000). If you want to generate longer paths, either change the
<a class='wikilink' href='../ConfiguringPRISM/Introduction.html'>default setting</a> or override it temporarily from the command-line using the <code>-simpathlen</code> switch.
You might also use the latter to decrease the setting,
e.g. to look for a path leading to a deadlock state,
but only within 100 steps:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism model.sm -simpath deadlock stdout -simpathlen 100</span><br/>
</div></div>
</div>
<hr />
<h1>Exporting The Model</h1>
<p>If required, once the model has been constructed it can be exported, either for manual examination or for use in another tool.
In the GUI, the "Model | Export" menu provides options to export various components of the model:
the set of reachable states, the transition matrix, the state rewards vector and the transition rewards matrix.
In all cases, it is possible to export this information either in plain text format or as <a class='urllink' href='http://www.mathworks.com/'>Matlab</a> code.
Additionally, matrices and vectors can be exported in a format suitable for import into the <a class='urllink' href='http://www.cs.utwente.nl/~zapreevis/mrmc'>MRMC</a> tool
and the transition matrix of the model can be exported in <a class='urllink' href='http://www.graphviz.org'>Dot</a> format
which allows easy graphical visualisation of the graph structure of the model.
The GUI also provides options in the "Model | View" menu,
which allow exports (in textual format) directly to the log.
This is convenient for quick examination of small models.
</p>
<p class='vspace'>All of this export functionality is available from the command-line version of PRISM, using the following switches:
</p>
<div class='vspace'></div><ul><li><code>-exportstates &lt;file&gt;</code>
</li><li><code>-exporttrans &lt;file&gt;</code>
</li><li><code>-exportstaterewards &lt;file&gt;</code>
</li><li><code>-exporttransrewards &lt;file&gt;</code>
</li><li><code>-exporttransdot &lt;file&gt;</code>
</li></ul><p class='vspace'>In each case, using <code>stdout</code> instead of a file name causes the information to be displayed directly to the screen.
To change the export format from the default (plain text) to Matlab or MRMC, use the <code>-exportmatlab</code> and <code>-exportmrmc</code> switches.
The export command-line switches can be used in combination.  For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism poll2.sm -exportstates poll2.sta -exporttrans poll2.tra -exportmatlab</span><br/>
</div></div>
</div>
<p class='vspace'>exports both the state space and transition matrix in Matlab format.
</p>
<p class='vspace'>Finally, there is some additional export functionality available only from the command-line.
</p>
<p class='vspace'>Firstly, in the case where both a model file and properties file have been specified,
it is possible to export the set of states satisfied by each label in the properties file, including the built-in labels <code>"init"</code> and <code>"deadlock"</code>.
This is done with the <code>-exportlabels</code> switch and the information
can be output either in plain text format (default) or for use with Matlab or MRMC (see switches above).
</p>
<p class='vspace'>Secondly, when outputting matrices for DTMCs or CTMCs, it is possible to request that PRISM does not sort the rows of the matrix,
as is normally the case. This is achieved with the <code>-exportunordered</code> switch.
The reason for this is that in this case PRISM does not need to construct an explicit version of the model in memory
and the process can thus be performed with reduced memory consumption.
</p>
<p class='vspace'>Finally, the <code>-exportrows</code> switch provides an alternative output format for transition matrices where the elements of each row of the matric are grouped on the same line. This can be particularly helpful for viewing the matrix for MDPs. By way of example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-style:italic;">0 0 13 0.5</span><br/>
<span style="font-style:italic;">0 0 26 0.5</span><br/>
<span style="font-style:italic;">0 1 1 0.5</span><br/>
<span style="font-style:italic;">0 1 2 0.5</span><br/>
<span style="font-style:italic;">1 0 14 0.5</span><br/>
<span style="font-style:italic;">1 0 27 0.5</span><br/>
<span style="font-style:italic;">1 1 3 0.5</span><br/>
<span style="font-style:italic;">1 1 4 0.5</span><br/>
</div></div>
</div>
<p class='vspace'>becomes:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-style:italic;">0 0.5:13 0.5:26</span><br/>
<span style="font-style:italic;">0 0.5:1 0.5:2</span><br/>
<span style="font-style:italic;">1 0.5:14 0.5:27</span><br/>
<span style="font-style:italic;">1 0.5:3 0.5:4</span><br/>
</div></div>
</div>
<hr />
<h1>Model Checking</h1>
<p>Typically, once a model has been constructed, it is analysed through model checking.
Properties are specified as described in the "<a class='wikilink' href='../PropertySpecification/Introduction.html'>Property Specification</a>" section,
and are usually kept in files with extension <code>.pctl</code> or <code>.csl</code>.
There are properties files accompanying most of the sample PRISM models in the <code>examples</code> directory.
</p>
<p class='vspace'>To load a file containing properties into the GUI, select menu option "Properties | Open properties list".
The file can only be loaded if there are no errors, otherwise an error is displayed.
Note that it may be necessary to have loaded the corresponding model first,
since the properties will probably make reference to variables (and perhaps constants) declared in the model file.
Once loaded, the properties contained in the file are displayed in a list in the "Properties" tab of the GUI.
Constants and labels are displayed in separate lists below.
You can modify or create new properties, constants and labels from the GUI,
by right-clicking on the appropriate list and selecting from the pop-up menu which appears.
Properties with errors are shaded red and marked with a warning sign.
Positioning the mouse pointer over the property displays the corresponding error message.
</p>
<p class='vspace'>The pop-up menu for the properties list also contains a "Verify" option,
which allows you instruct PRISM to model check the currently selected properties
(hold down Ctrl to select more than one property simultaneously).
All properties can be model checked at once by selecting "Verify all".
PRISM verifies each property individually.
Upon completion, the icon next to the property changes according to the result of model checking.
A green tick indicates that the property is satisfied in all states of the model; a red cross that this is not the case.
As mentioned earlier, if you just want to know whether or not
the property is satisfied in the initial states of the model,
prefix the property with <code>"init" =&gt;</code>.
For properties which have a numerical result (e.g. <code>P=? [ ...]</code>),
position the mouse pointer over the property to view the result.
In addition, this and further information about model checking is displayed in the log in the "Log" tab.
</p>
<p class='vspace'>From the command-line, model checking is achieved by passing both a model file and a properties file as arguments, e.g.:
</p>
<p class='vspace'><code class='escaped'> prism poll2.sm poll.csl </code>
</p>
<p class='vspace'>By default, all properties in the file are checked.
To model check only a single property, use the <code>-prop</code> switch.
For example, to check only the fourth property in the file:
</p>
<p class='vspace'><code class='escaped'> prism poll2.sm poll.csl -prop 4 </code>
</p>
<p class='vspace'>Alternatively, a single property can be specified directly from the command-line,
using the (equivalent) <code>-pctl</code> and <code>-csl</code> switches:
</p>
<p class='vspace'><code class='escaped'> prism poll2.sm -csl 'P&gt;=0.5 [ true U&lt;=5 (s=1 &amp; a=0) ]' </code>
</p>
<p class='vspace'>Note the use of single quotes (<code>'...'</code>) to avoid characters such as
<code>(</code> and <code>&gt;</code> being interpreted by the command-line shell.
The results of model checking are sent to the display and are as described above for the GUI version.
</p><hr />
<h1>Approximate Computation Of Quantitative Properties</h1>
<p>The discrete-event simulator built in to PRISM (see the section "<a class='wikilink' href='../RunningPRISM/DebuggingModelsWithTheSimulator.html'>Debugging Models With The Simulator</a>") can also be used to generate approximate values for PRISM
properties which give quantitative results, namely properties of the form <code><strong>P=?</strong>[...]</code> and <code><strong>R=?</strong>[...]</code>.
This is achieved by <em>sampling</em>: generating a large number of random runs through the model,
evaluating the result of the given properties on each run, and then averaging the results.
This approach is particularly useful on very large models when normal model
checking is infeasible. This is because discrete-event simulation is performed using
the PRISM language model description, without actually constructing the probabilistic
model.
</p>
<p class='vspace'>To use this functionality, load a model and some properties into PRISM, as described in the previous sections. To generate an
approximate value for one or more properties, select them in the list, right-click
and select "Simulate" (as opposed to "Verify"). As usual, it is first necessary to
provide values for any undefined constants. Subsequently, a dialog appears. Here, the
state for which values are to be computed (i.e. from which the paths will be generated) can be selected. By default, this is
initial state of the model. The number of paths (samples) and the maximum length of
each path which will be generated by PRISM to compute approximate values can be
modified as required. The related parameters of <em>confidence</em> and <em>approximation</em> can
also be viewed or edited. Informally, for a given number of paths, the probability that the
difference between computed and actual answers is bigger than the approximation
parameter is at most equal to the confidence parameter.
See for example [<a class='wikilink' href='References.html#HLMP04'>HLMP04</a>] for a more in-depth discussion of these concepts.
By default in PRISM the approximation parameter is 0.01 and the confidence parameter is 1e-10.
In this case, the number of paths/samples required is 402,412.
</p>
<p class='vspace'>Finally, approximate generation of results can also be activated from the command-line using
the <code>-sim</code> switch. To change the approximation parameter, confidence parameter, number
of samples and maximum path length, respectively, use the switches <code>-simapprox</code>, <code>-simconf</code>, <code>-simsamples</code> and <code>-simpathlen</code>.
Here is an example of activating the simulator from the command-line:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism dice.pm dice.pctl -sim -simconf 1e-1</span><br/>
</div></div>
</div>
<p class='vspace'>Currently, the simulator does not support every part of the PRISM modelling and property languages. For example, it does not handle models with multiple initial states or with <code><strong>system</strong>...<strong>endsystem</strong></code> definitions and it does not handle properties containing LTL-style path properties or arithmetic combinations of <code><strong>P=?</strong>[...]</code> and <code><strong>R=?</strong>[...]</code> properties.
</p><hr />
<h1>Computing Steady-state And Transient Probabilities</h1>
<p>If the model is a CTMC or DTMC, it is possible to compute corresponding vectors of
steady-state or transient probabilities directly
(rather than indirectly by analysing a property which requires their computation).
From the GUI, select an option from the "Model | Compute" menu.
For transient probabilities, you will be asked to supply the
time value for which you wish to compute probabilities.
From the command-line, add the <code>-steadystate</code> (or <code>-ss</code>) switch:
</p>
<p class='vspace'><code class='escaped'> prism poll2.sm -ss </code>
</p>
<p class='vspace'>for steady-state probabilities or the <code>-transient</code> (or <code>-tr</code>) switch:
</p>
<p class='vspace'><code class='escaped'> prism poll2.sm -tr 100.0 </code>
</p>
<p class='vspace'>for transient probabilities, again specifying a time value in the latter case.
The probabilities are computed for all states of the model and displayed,
either on the screen (from the command-line) or in the log (from the GUI).
For both steady-state and transient probability computation,
PRISM assumes that the initial probability distribution of the CTMC is
an equiprobable choice over the set of initial states.
</p><hr />
<h1>Experiments</h1>
<p>PRISM supports <em>experiments</em>, which is a way of automating multiple instances of model checking.
This is done by leaving one or more <a class='wikilink' href='../ThePRISMLanguage/Constants.html'>constants</a> undefined, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">N</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">T</span>;<br/>
</div></div>
</div>
<p class='vspace'>This can be done for constants in the model file, the properties file, or both.
Before any verification can be performed, values must be provided for any such constants.
In the GUI, a dialog appears in which the user is required to enter values.
From the command line, the <code>-const</code> switch must be used, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism cluster.sm cluster.csl -const N=4,T=85.9</span><br/>
</div></div>
</div>
<p class='vspace'>You can also provide ranges of variables for one or more of the constants, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism cluster.sm cluster.csl -const N=4:6,T=60:10:100</span><br/>
</div></div>
</div>
<p class='vspace'>where <code>N=4:6</code> means that values of 4,5 and 6 are used for <code>N</code>,
and <code>T=60:10:100</code> means that values of 60, 70, 80, 90 and 100 (i.e. steps of 10) are used for <code>T</code>.
Model checking is performed for all combinations of the constant values provided.
Using the switch <code>-exportresults file</code>, you can send a tabulated copy of all the model checking results generated to the file <code>file</code>.
For convenience, constant specifications can split across separate instances of the <code>-const</code> switch, if desired.
</p>
<p class='vspace'>From the GUI, the same thing can be achieved by selecting a single property,
right clicking on it and selecting "New experiment"
(or alternatively using the popup menu in the "Experiments" panel).
Values or ranges for each undefined constant can then be supplied in the resulting dialog.
Details of the new experiment and its progress are shown in the panel.
To stop the experiment before it has completed, click the red "Stop" button and it will
halt after finishing the current iteration of model checking.
Once the experiment has finished, right clicking on the experiment produces a pop-up menu,
from which you can view the results of the experiment or export them to a file.
</p>
<p class='vspace'>For experiments based on properties which return numerical results, you can also use the GUI to plot graphs of the results.
This can be done either before the experiment starts, by selecting the "Create graph" tick-box in the dialog used to create the experiment
(in fact this box is ticked by default), or after the experiment's completion, by choosing "Plot results" from the pop-up menu on the experiment.
A dialog appears, where you can choose which constant (if there are more than one) to use for the x-axis of the graph,
and for which values of any other constants the results should be plotted.
The graph will appear in the panel below the list of experiments.
Right clicking on a graph and selecting "Graph options" brings up a dialog from which many properties of the graph can be configured.
From the pop-up menu of a graph, you can also choose to print the graph (to a printer or Postscript file)
or export it in a variety of formats:
as an image (PNG or JPEG),
as an encapsulated Postscript file (EPS),
in an XML-based format (for reloading back into PRISM),
or as code which can be used to generate the graph in Matlab.
</p>
<p class='vspace'>Approximate computation of quantitive results obtained with the <a class='wikilink' href='../RunningPRISM/ApproximateComputationOfQuantitativeProperties.html'>simulator</a> can also be used on experiments. In the GUI, select the "Use Simulation" option when defining the parameters for the experiment. From the command-line, just add the <code>-sim</code> switch as usual.
</p><hr />
<h1>Support For PEPA Models</h1>
<p>For CTMCs, PRISM also accepts model descriptions in the stochastic process algebra <a class='urllink' href='http://www.dcs.ed.ac.uk/pepa/'>PEPA</a> [<a class='wikilink' href='References.html#Hil96'>Hil96</a>].
The tool compiles such descriptions into the PRISM language and then constructs the model as normal.
The language accepted by the PEPA to PRISM compiler is actually a subset of PEPA.
The restrictions applied to the language are firstly that component identifiers can only be bound to sequential components
(formed using prefix and choice and references to other sequential components only).
Secondly, each local state of a  sequential component must be named.  For example, we would rewrite:
</p>
<div class='vspace'></div><ul><li>P = (a,r).(b,s).P;
</li></ul><p class='vspace'>as:
</p>
<div class='vspace'></div><ul><li>P = (a,r).P';
</li><li>P' = (b,s).P;
</li></ul><p class='vspace'>Finally, active/active synchronisations are not allowed since the PRISM 
definition of these differs from the PEPA definition.  Every PEPA 
synchronisation must have exactly one active component.
Some examples of PEPA model descriptions which can be imported into PRISM
can be found in the <code>examples/pepa</code> directory.
</p>
<p class='vspace'>From the command-line version of PRISM, add the <code>-importpepa</code> switch and the model will be treated as a PEPA description.
From the GUI, select "Model | Open model" and then choose "PEPA models"
on the "Files of type" drop-down menu.
Alternatively, select "Model | New | PEPA model" and either type a description from scratch
or paste in an existing one from elsewhere.
Once the PEPA model has been successfully parsed by PRISM,
you can view the corresponding PRISM code (as generated by the PEPA-to-PRISM compiler)
by selecting menu option "Model | View | Parsed PRISM model".
</p><hr />
<h1>Support For SBML</h1>
<p>PRISM includes a (prototype) tool to translate specifications in <a class='urllink' href='http://sbml.org/'>SBML</a> (Systems Biology Markup Language) to model descriptions in the PRISM language. SBML is an XML-based format for representing models of biochemical reaction networks. The translator currently works with Level 2 Version 1 of the SBML specification, details of which can be found <a class='urllink' href='http://sbml.org/documents/'>here</a>. Level 1 SBML files will first need to be translated into equivalent Level 2 files, for example using <a class='urllink' href='http://sbml.org/tools/htdocs/sbmltools.php'>this on-line converter</a>.
</p>
<p class='vspace'>Since PRISM is a tool for analysing discrete-state systems, the translator is designed for SBML files intended for discrete stochastic simulation. A useful set of such files can be found in the CaliBayes <a class='urllink' href='http://www.calibayes.ncl.ac.uk/Resources/dsmts/'>Discrete Stochastic Model Test Suite</a>. There are also many more SBML files available in the <a class='urllink' href='http://www.ebi.ac.uk/biomodels/'>BioModels Database</a>.
</p>
<p class='vspace'>We first give a simple example of an SBML file and its PRISM translation. We then give some more precise details of the translation process.
</p>
<div class='vspace'></div><h3>Example</h3>
<p>An SBML file comprises a set of <em>species</em> and a set of <em>reactions</em> which they undergo. Below is the SBML file for the simple reversible reaction: <strong>Na + Cl &#8596; Na<sup>+</sup> + Cl<sup>-</sup></strong>, where there are initially 100 Na and Cl atoms and no ions, and the base rates for the forwards and backwards reactions are 100 and 10, respectively.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="xml" style="font-family: monospace;"><span class="sc3"><span class="re1">&lt;?xml</span> <span class="re0">version</span>=<span class="st0">&quot;1.0&quot;</span> <span class="re0">encoding</span>=<span class="st0">&quot;UTF-8&quot;</span><span class="re2">?&gt;</span></span><br />
<span class="sc3"><span class="re1">&lt;sbml</span> <span class="re0">xmlns</span>=<span class="st0">&quot;http://www.sbml.org/sbml/level2&quot;</span> <span class="re0">metaid</span>=<span class="st0">&quot;_000000&quot;</span> <span class="re0">level</span>=<span class="st0">&quot;2&quot;</span> <span class="re0">version</span>=<span class="st0">&quot;1&quot;</span><span class="re2">&gt;</span></span><br />
&nbsp; <span class="sc3"><span class="re1">&lt;model</span> <span class="re0">id</span>=<span class="st0">&quot;nacl&quot;</span> <span class="re0">name</span>=<span class="st0">&quot;Na+Cl&quot;</span><span class="re2">&gt;</span></span><br />
<br />
&nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfCompartments<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;compartment</span> <span class="re0">id</span>=<span class="st0">&quot;compartment&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfCompartments<span class="re2">&gt;</span></span></span><br />
<br />
&nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfSpecies<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;species</span> <span class="re0">id</span>=<span class="st0">&quot;na&quot;</span> <span class="re0">initialAmount</span>=<span class="st0">&quot;100&quot;</span> <span class="re0">hasOnlySubstanceUnits</span>=<span class="st0">&quot;true&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;species</span> <span class="re0">id</span>=<span class="st0">&quot;cl&quot;</span> <span class="re0">initialAmount</span>=<span class="st0">&quot;100&quot;</span> <span class="re0">hasOnlySubstanceUnits</span>=<span class="st0">&quot;true&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;species</span> <span class="re0">id</span>=<span class="st0">&quot;na_plus&quot;</span> <span class="re0">initialAmount</span>=<span class="st0">&quot;0&quot;</span> <span class="re0">hasOnlySubstanceUnits</span>=<span class="st0">&quot;true&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;species</span> <span class="re0">id</span>=<span class="st0">&quot;cl_minus&quot;</span> <span class="re0">initialAmount</span>=<span class="st0">&quot;0&quot;</span> <span class="re0">hasOnlySubstanceUnits</span>=<span class="st0">&quot;true&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfSpecies<span class="re2">&gt;</span></span></span><br />
<br />
&nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfReactions<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;reaction</span> <span class="re0">id</span>=<span class="st0">&quot;forwards&quot;</span> <span class="re0">reversible</span>=<span class="st0">&quot;false&quot;</span><span class="re2">&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfReactants<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;na&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;cl&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfReactants<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfProducts<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;na_plus&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;cl_minus&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfProducts<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;kineticLaw<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;math</span> <span class="re0">xmlns</span>=<span class="st0">&quot;http://www.w3.org/1998/Math/MathML&quot;</span><span class="re2">&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;apply<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;times</span><span class="re2">/&gt;</span></span><span class="sc3"><span class="re1">&lt;ci<span class="re2">&gt;</span></span></span>forwards_rate<span class="sc3"><span class="re1">&lt;/ci<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;apply<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;times</span><span class="re2">/&gt;</span></span><span class="sc3"><span class="re1">&lt;ci<span class="re2">&gt;</span></span></span>na<span class="sc3"><span class="re1">&lt;/ci<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;ci<span class="re2">&gt;</span></span></span>cl<span class="sc3"><span class="re1">&lt;/ci<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;/apply<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;/apply<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/math<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfParameters<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;parameter</span> <span class="re0">id</span>=<span class="st0">&quot;forwards_rate&quot;</span> <span class="re0">value</span>=<span class="st0">&quot;100&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfParameters<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/kineticLaw<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/reaction<span class="re2">&gt;</span></span></span><br />
<br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;reaction</span> <span class="re0">id</span>=<span class="st0">&quot;backwards&quot;</span> <span class="re0">reversible</span>=<span class="st0">&quot;false&quot;</span><span class="re2">&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfReactants<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;na_plus&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;cl_minus&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfReactants<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfProducts<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;na&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;speciesReference</span> <span class="re0">species</span>=<span class="st0">&quot;cl&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfProducts<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;kineticLaw<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;math</span> <span class="re0">xmlns</span>=<span class="st0">&quot;http://www.w3.org/1998/Math/MathML&quot;</span><span class="re2">&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;apply<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;times</span><span class="re2">/&gt;</span></span><span class="sc3"><span class="re1">&lt;ci<span class="re2">&gt;</span></span></span>backwards_rate<span class="sc3"><span class="re1">&lt;/ci<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;apply<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;times</span><span class="re2">/&gt;</span></span><span class="sc3"><span class="re1">&lt;ci<span class="re2">&gt;</span></span></span>na_plus<span class="sc3"><span class="re1">&lt;/ci<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;ci<span class="re2">&gt;</span></span></span>cl_minus<span class="sc3"><span class="re1">&lt;/ci<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;/apply<span class="re2">&gt;</span></span></span><span class="sc3"><span class="re1">&lt;/apply<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/math<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;listOfParameters<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;parameter</span> <span class="re0">id</span>=<span class="st0">&quot;backwards_rate&quot;</span> <span class="re0">value</span>=<span class="st0">&quot;10&quot;</span><span class="re2">/&gt;</span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfParameters<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/kineticLaw<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/reaction<span class="re2">&gt;</span></span></span><br />
&nbsp; &nbsp; <span class="sc3"><span class="re1">&lt;/listOfReactions<span class="re2">&gt;</span></span></span><br />
<br />
&nbsp; <span class="sc3"><span class="re1">&lt;/model<span class="re2">&gt;</span></span></span><br />
<span class="sc3"><span class="re1">&lt;/sbml<span class="re2">&gt;</span></span></span></div></div>
</div>
<p class='vspace'>And here is the resulting PRISM code:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismcomment">// File generated by automatic SBML-to-PRISM conversion</span><br/>
<span class="prismcomment">// Original SBML file: nacl.xml</span><br/>
<br/>
<span class="prismkeyword">ctmc</span><br/>
<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">MAX_AMOUNT</span> = <span class="prismnum">100</span>;<br/>
<br/>
<span class="prismcomment">// Parameters for reaction forwards</span><br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">forwards_rate</span> = <span class="prismnum">100</span>; <span class="prismcomment">// forwards_rate</span><br/>
<br/>
<span class="prismcomment">// Parameters for reaction backwards</span><br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">backwards_rate</span> = <span class="prismnum">10</span>; <span class="prismcomment">// backwards_rate</span><br/>
<br/>
<span class="prismcomment">// Species na</span><br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">na_MAX</span> = <span class="prismident">MAX_AMOUNT</span>;<br/>
<span class="prismkeyword">module</span> <span class="prismident">na</span><br/>
<br/>
	<span class="prismident">na</span> : [<span class="prismnum">0</span>..<span class="prismident">na_MAX</span>] <span class="prismkeyword">init</span> <span class="prismnum">100</span>; <span class="prismcomment">// Initial amount 100</span><br/>
<br/>
	<span class="prismcomment">// forwards</span><br/>
	[<span class="prismident">forwards</span>] <span class="prismident">na</span> &gt; <span class="prismnum">0</span> -&gt; (<span class="prismident">na</span>'=<span class="prismident">na</span>-<span class="prismnum">1</span>);<br/>
	<span class="prismcomment">// backwards</span><br/>
	[<span class="prismident">backwards</span>]&nbsp;&nbsp;<span class="prismident">na</span> &lt;= <span class="prismident">na_MAX</span>-<span class="prismnum">1</span> -&gt; (<span class="prismident">na</span>'=<span class="prismident">na</span>+<span class="prismnum">1</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismcomment">// Species cl</span><br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">cl_MAX</span> = <span class="prismident">MAX_AMOUNT</span>;<br/>
<span class="prismkeyword">module</span> <span class="prismident">cl</span><br/>
<br/>
	<span class="prismident">cl</span> : [<span class="prismnum">0</span>..<span class="prismident">cl_MAX</span>] <span class="prismkeyword">init</span> <span class="prismnum">100</span>; <span class="prismcomment">// Initial amount 100</span><br/>
<br/>
	<span class="prismcomment">// forwards</span><br/>
	[<span class="prismident">forwards</span>] <span class="prismident">cl</span> &gt; <span class="prismnum">0</span> -&gt; (<span class="prismident">cl</span>'=<span class="prismident">cl</span>-<span class="prismnum">1</span>);<br/>
	<span class="prismcomment">// backwards</span><br/>
	[<span class="prismident">backwards</span>]&nbsp;&nbsp;<span class="prismident">cl</span> &lt;= <span class="prismident">cl_MAX</span>-<span class="prismnum">1</span> -&gt; (<span class="prismident">cl</span>'=<span class="prismident">cl</span>+<span class="prismnum">1</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismcomment">// Species na_plus</span><br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">na_plus_MAX</span> = <span class="prismident">MAX_AMOUNT</span>;<br/>
<span class="prismkeyword">module</span> <span class="prismident">na_plus</span><br/>
<br/>
	<span class="prismident">na_plus</span> : [<span class="prismnum">0</span>..<span class="prismident">na_plus_MAX</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>; <span class="prismcomment">// Initial amount 0</span><br/>
<br/>
	<span class="prismcomment">// forwards</span><br/>
	[<span class="prismident">forwards</span>]&nbsp;&nbsp;<span class="prismident">na_plus</span> &lt;= <span class="prismident">na_plus_MAX</span>-<span class="prismnum">1</span> -&gt; (<span class="prismident">na_plus</span>'=<span class="prismident">na_plus</span>+<span class="prismnum">1</span>);<br/>
	<span class="prismcomment">// backwards</span><br/>
	[<span class="prismident">backwards</span>] <span class="prismident">na_plus</span> &gt; <span class="prismnum">0</span> -&gt; (<span class="prismident">na_plus</span>'=<span class="prismident">na_plus</span>-<span class="prismnum">1</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismcomment">// Species cl_minus</span><br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">cl_minus_MAX</span> = <span class="prismident">MAX_AMOUNT</span>;<br/>
<span class="prismkeyword">module</span> <span class="prismident">cl_minus</span><br/>
<br/>
	<span class="prismident">cl_minus</span> : [<span class="prismnum">0</span>..<span class="prismident">cl_minus_MAX</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>; <span class="prismcomment">// Initial amount 0</span><br/>
<br/>
	<span class="prismcomment">// forwards</span><br/>
	[<span class="prismident">forwards</span>]&nbsp;&nbsp;<span class="prismident">cl_minus</span> &lt;= <span class="prismident">cl_minus_MAX</span>-<span class="prismnum">1</span> -&gt; (<span class="prismident">cl_minus</span>'=<span class="prismident">cl_minus</span>+<span class="prismnum">1</span>);<br/>
	<span class="prismcomment">// backwards</span><br/>
	[<span class="prismident">backwards</span>] <span class="prismident">cl_minus</span> &gt; <span class="prismnum">0</span> -&gt; (<span class="prismident">cl_minus</span>'=<span class="prismident">cl_minus</span>-<span class="prismnum">1</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismcomment">// Reaction rates</span><br/>
<span class="prismkeyword">module</span> <span class="prismident">reaction_rates</span><br/>
<br/>
	<span class="prismcomment">// forwards</span><br/>
	[<span class="prismident">forwards</span>] (<span class="prismident">forwards_rate</span>*(<span class="prismident">na</span>*<span class="prismident">cl</span>)) &gt; <span class="prismnum">0</span> -&gt; (<span class="prismident">forwards_rate</span>*(<span class="prismident">na</span>*<span class="prismident">cl</span>)) : <span class="prismkeyword">true</span>;<br/>
	<span class="prismcomment">// backwards</span><br/>
	[<span class="prismident">backwards</span>] (<span class="prismident">backwards_rate</span>*(<span class="prismident">na_plus</span>*<span class="prismident">cl_minus</span>)) &gt; <span class="prismnum">0</span> -&gt; (<span class="prismident">backwards_rate</span>*(<span class="prismident">na_plus</span>*<span class="prismident">cl_minus</span>)) : <span class="prismkeyword">true</span>;<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismcomment">// Reward structures (one per species)</span><br/>
<br/>
<span class="prismcomment">// 1</span><br/>
<span class="prismkeyword">rewards</span> "<span class="prismident">na</span>" <span class="prismkeyword">true</span> : <span class="prismident">na</span>; <span class="prismkeyword">endrewards</span><br/>
<span class="prismcomment">// 2</span><br/>
<span class="prismkeyword">rewards</span> "<span class="prismident">cl</span>" <span class="prismkeyword">true</span> : <span class="prismident">cl</span>; <span class="prismkeyword">endrewards</span><br/>
<span class="prismcomment">// 3</span><br/>
<span class="prismkeyword">rewards</span> "<span class="prismident">na_plus</span>" <span class="prismkeyword">true</span> : <span class="prismident">na_plus</span>; <span class="prismkeyword">endrewards</span><br/>
<span class="prismcomment">// 4</span><br/>
<span class="prismkeyword">rewards</span> "<span class="prismident">cl_minus</span>" <span class="prismkeyword">true</span> : <span class="prismident">cl_minus</span>; <span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>From the latter, we can use PRISM to generate a simple plot of the expected amount of Na and Na+ over time (using both model checking and a single random trace from the simulator):
</p>
<div class='vspace'></div><div><a class='urllink' href='../uploads/sbml_ex_graph.png'><img src='../uploads/sbml_ex_graph.png' alt='' title='' /></a><br /><strong>Expected amount of Na/Na+ at time T</strong></div>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Using the translator</h3>
<p>At present, the SBML-to-PRISM translator is included in the PRISM code-base, but not integrated into the application itself. To perform a conversion:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">cd prism</span><br/>
<span style="font-weight:bold;">java -cp classes prism.SBML2Prism sbml_file.xml &gt; prism_file.sm</span><br/>
</div></div>
</div>
<p class='vspace'>Alternatively (on Linux or Mac OS X), ensure <code>prism</code> is in your path and then save the script below as an executable file called <code>sbml2prism</code>:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="bash" style="font-family: monospace;"><span class="re3">#!/bin/sh</span><br />
<br />
<span class="re3"># Startup script <span class="kw1">for</span> SBML-to-PRISM translator</span><br />
<br />
<span class="re3"># Launch using main PRISM script</span><br />
<span class="re2">PRISM_MAINCLASS=</span><span class="st0">&quot;prism.SBML2Prism&quot;</span><br />
<span class="kw3">export</span> PRISM_MAINCLASS<br />
prism <span class="st0">&quot;$@&quot;</span></div></div>
</div>
<p class='vspace'>Then use:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">sbml2prism sbml_file.xml &gt; prism_file.sm</span><br/>
</div></div>
</div>
<p class='vspace'>The following PRISM properties file will also be useful:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">T</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">c</span>;<br/>
<br/>
<span class="prismkeyword">R</span>{<span class="prismident">c</span>}=? [<span class="prismkeyword">I</span>=<span class="prismident">T</span>]<br/>
</div></div>
</div>
<p class='vspace'>This contains a single property which, based on the reward structures in the PRISM model generated by the translator, means "the expected amount of species <em>c</em> at time <em>T</em>". The constant <em>c</em> is an integer index which can range between 1 and <em>N</em>, where <em>N</em> is the number of species in the model. To view the expected amount of each species over time, create an <a class='wikilink' href='../RunningPRISM/Experiments.html'>experiment</a> in PRISM which varies <em>c</em> from 1 to <em>N</em> and <em>T</em> over the desired time range.
</p>
<div class='vspace'></div><hr />
<div class='vspace'></div><h3>Details of the translation</h3>
<p>The basic structure of the translation process is as follows:
</p>
<div class='vspace'></div><ul><li>Each <em>species</em> in the SBML file is represented by a <a class='wikilink' href='../ThePRISMLanguage/ModulesAndVariables.html'>module</a> in the resulting PRISM file. This module, which (where possible) retains the SBML species id as its name, contains a single <a class='wikilink' href='../ThePRISMLanguage/ModulesAndVariables.html'>variable</a> whose value represents the amount of the species present. A corresponding <a class='wikilink' href='../ThePRISMLanguage/CostsAndRewards.html'>reward structure</a> for computing the expected amount of the species at a given time instant is also created. Species for which the <code>boundaryCondition</code> flag is set to <code>true</code> in the SBML file do not have a corresponding module.
<div class='vspace'></div></li><li>Each <em>reaction</em> in the SBML file is associated with a unique <a class='wikilink' href='../ThePRISMLanguage/Synchronisation.html'>synchronisation action label</a>. The module for each species which takes part in the reaction will include a synchronous <a class='wikilink' href='../ThePRISMLanguage/Commands.html'>command</a> to represent this. An additional PRISM module called <code>reaction_rates</code> stores the expression representing the rate of each reaction (from the corresponding <code>kineticLaw</code> section in the SBML file). Reaction stoichiometry information is respected but must be provided in the scalar <code>stoichiometry</code> field of a <code>speciesReference</code> element, not in a separate <code>StoichiometryMath</code> element.
<div class='vspace'></div></li><li>Each <em>parameter</em> in the SBML file, either global to the file or specific to a reaction, becomes a <a class='wikilink' href='../ThePRISMLanguage/Constants.html'>constant</a> in the PRISM file. If a value for this parameter is given, it used. If not, the constant is left as undefined.
</li></ul><p class='vspace'>As described above, this translation process is designed for discrete systems and so the amount of each species in the model is represented by an integer variable. It is therefore assumed that the initial amount for each species specified in the SBML file is also given as an integer. If this is not the case, then the values will need to be scaled accordingly first.
</p>
<p class='vspace'>Furthermore, since PRISM is primarily a model checking (rather than simulation) tool, it is important that the amount of each species also has an upper bound (to ensure a finite state space). When model checking, the efficiency (or even feasibility) of the process is likely to be very sensitive to the upper bound(s) chosen. When using the discrete-event simulation functionality of PRISM, this is not the case and the bounds can can be set much higher. By default the translator uses an upper bound of 100 (which is increased if the initial amount exceeds this). A different value can specified through a second command-line argument as follows:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">cd prism</span><br/>
<span style="font-weight:bold;">java -cp classes prism.SBML2Prism sbml_file.xml 1000 &gt; prism_file.sm</span><br/>
</div></div>
</div>
<p class='vspace'>Alternatively, upper bounds can be modified manually after the translation process.
</p>
<p class='vspace'>Finally, The following aspects of SBML files are not currently supported and are ignored during the translation process:
</p>
<div class='vspace'></div><ul><li>compartments
</li><li>events/triggers
</li></ul><hr />
<h1>Explicit Model Import</h1>
<p>It is also now possible to construct models in PRISM through direct specification of their transition matrix.
The format in which this information is input to the tool is exactly the same as is currently output
(see the section <a class='wikilink' href='../RunningPRISM/ExportingTheModel.html'>Exporting The Model</a>).
Presently, this functionality is only supported in the command-line version of the tool, using the <code>-importtrans</code> switch.
At the moment, PRISM makes no attempt to discern the model type from the input file.
By default it assumes that the model is an MDP.
If this is not the case, the model type can be overwritten using the <code>-dtmc</code>, <code>-ctmc</code> and <code>-mdp</code> switches.
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism -importtrans poll2.tra -ctmc</span><br/>
</div></div>
</div>
<p class='vspace'>Please note that this method of constructing models in PRISM is typically less efficient than using the PRISM language.
This is because PRISM is a symbolic model checker and the underlying data structures used to represent the model
function better when there is high-level structure and regularity to exploit.
This situation can be alleviated to a certain extent by importing not just a transition matrix,
but also a definition of each state of the model in terms of a set of variables.
The format of this information is again identical to PRISM's current output format, using the <code>-exportstates</code> switch.
The following example shows how PRISM could be used to build, export and then re-import a model
(not a good strategy in general):
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism poll2.sm -exporttrans poll2.tra -exportstates poll2.sta</span><br/>
<span style="font-weight:bold;">prism -importtrans poll2.tra -importstates poll2.sta -ctmc</span><br/>
</div></div>
</div>
<p class='vspace'>Lastly, since details about the initial state of a model is not preserved in the files output from <code>-exportstates</code> and <code>-exporttrans</code>, this information needs to specified separately.
If not, the default is to assume a single initial state, in which all variables take their minimum value (if <code>-importstates</code> is not used, the model has a a single zero-indexed variable <code>x</code>, and the initial state is <code>x=0</code>).
</p>
<p class='vspace'>To specify an alternative set of initial states, use the switch <code>-importlabels</code>, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism -importtrans poll2.tra -importstates poll2.sta -importlabels poll2.lab -ctmc</span><br/>
</div></div>
</div>
<p class='vspace'>where the labels file (<code>poll2.lab</code> above) is in the format generated by the <code>-exportlabels</code> <a class='wikilink' href='../RunningPRISM/ExportingTheModel.html'>export option</a> of PRISM. Currently, the <code>-importlabels</code> swicth does not import any other label information - just the set of initial states.
<br /><br />
</p><hr />
<div class='vspace'></div><h1><span class='big'>Configuring PRISM</span></h1>
<hr />
<h1>Introduction</h1>
<p>The operation of PRISM can be configured in a number of ways. From the GUI, select "Options" from the main menu to bring up the "Options" dialog. The settings are grouped under several tabs. Those which affect the basic model checking functionality of the tool are under the heading "PRISM". Separate settings are available for the simulator and various aspects of the GUI (the model editor, the property editor and the log).
</p>
<p class='vspace'>From the command-line version, options are controlled by switches. A full list can be displayed by typing:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism -help</span><br/>
</div></div>
</div>
<p class='vspace'>In the following sections, we give a brief description of the most important configuration options available.
</p>
<p class='vspace'>User options and settings are saved locally and reused. They are stored in the file <code>.prism</code>, which can be found in your home directory (<code>~</code>) under Unix, Linux or Mac OS X and in e.g. <code>C:\Documents and Settings\username</code> under Windows. The settings are used by both the command-line and GUI versions of PRISM. Currently the "Options" dialog in the GUI represents the easiest way to modify the settings, but the <code>.prism</code> file is in a simple textual format and can be edited by hand.
</p>
<p class='vspace'>To restore the default options for PRISM, click "Load Defaults" and then "Save Options" from the "Options" dialog in the GUI. Alternatively, delete the <code>.prism</code> file and then run PRISM.
</p><hr />
<h1>Computation Engines</h1>
<h3>Computation engines</h3>
<p>An important feature of the tool is its <em>engines</em>.
PRISM is a symbolic model checker: its basic underlying data structures are BDDs and MTBDDs.
When performing numerical computation, however, the tool can use one of three engines.
The first is implemented purely in <em>MTBDDs</em> (and BDDs); the second uses <em>sparse matrices</em>;
and the third is a <em>hybrid</em>, using a combination of the other two.
</p>
<p class='vspace'>The choice of engine ("MTBDD", "sparse" or "hybrid") will not affect the results of model checking -
all engines perform the same calculations
(although in a few cases, some types of computation can only be performed with certain engines).
Performance (time and space), however, may vary significantly and if you are using too much time/memory with one engine, it may be worth experimenting. Below, we briefly summarise the key characteristics of each engine.
</p>
<div class='vspace'></div><ul><li><strong>The hybrid engine</strong> is enabled by default in PRISM. It uses a combination of <em>symbolic</em> and <em>explicit</em> data structures (as used in the MTBDD and sparse engines, respectively). In general it provides the best compromise between time and memory usage: it (almost) always uses less memory than the sparse engine, but is typically slightly slower. The size of model which can be handled with this engine is quite predictable. The limiting factor in terms of memory usage comes from the storage of 2-4 (depending on the computation being performed) arrays of 8-byte values, one for each state in the model. So, a typical PC can handle models with between 10<sup>7</sup> and 10<sup>8</sup> states (one vector for 10<sup>7</sup> states uses approximately 75 MB).
<div class='vspace'></div></li><li><strong>The sparse engine</strong> can be a good option for smaller models where model checking takes a long time. For larger models, however, memory usage quickly becomes prohibitive. As a rule of thumb, the upper limit for this engine, in terms of model sizes which can be handled, is about a factor of 10 less than the hybrid engine.
<div class='vspace'></div></li><li><strong>The MTBDD engine</strong> is much more unpredictable in terms of performance but, when a model exhibits a lot of structure and regularity, can be very effective. This engine has been successfully applied to extremely large structured (but non-trivial) models, in cases where the other two engines cannot be applied. The MTBDD engine often performs poorly when the model (or solutions computed from it) contain lots of distinct probabilities/rates; it performs best when there are few such values. For this reason the engine is often successfully applied to MDP models, but much less frequently to CTMCs. When using the MTBDD engine, the <em>variable ordering</em> of your model is especially important. This topic is covered in the <a class='wikilink' href='../FrequentlyAskedQuestions/PRISMModelling.html#ordering'>FAQ</a> section.
</li></ul><p class='vspace'>When using the PRISM GUI, the engine to be used for model checking can be selected from the "Engine" option under the "PRISM" tab of the "Options" dialog. From the command-line, engines are activated using the <code>-mtbdd</code>, <code>-sparse</code> and <code>-hybrid</code> (or <code>-m</code>, <code>-s</code> and <code>-h</code>, respectively) switches, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="shell"><span style="font-weight:bold;">prism poll2.sm -tr 1000 -s</span><br/>
</div></div>
</div>
<p class='vspace'>For further information and technical details about PRISM's implementation and engines, see: [<a class='wikilink' href='References.html#Par02'>Par02</a>],[<a class='wikilink' href='References.html#KNP04b'>KNP04b</a>].
</p>
<p class='vspace'>Note also that precise details regarding the memory usage of the current engine are displayed during model checking (from the GUI, check the "Log" tab). This can provide valuable feedback when experimenting with different engines.
</p><hr />
<h1>Iterative Numerical Methods</h1>
<p>For performing the computation of probabilities and expected costs/rewards during verification, PRISM uses iterative numerical methods. The methods used vary depending on the type of verification being performed. In some cases, PRISM solves systems of linear equation systems (e.g. "until" properties for DTMCs and CTMCs, steady-state properties for CTMCs and "reachability reward" properties for DTMCs). For this, a range of methods are available (see below). For "until" and "reachability reward" properties of MDPs, PRISM uses a method called "value iteration". For computations involving transient probabilities of CTMCs (e.g. "bounded until" and "cumulative reward" properties), it uses a method called "uniformisation".
</p>
<div class='vspace'></div><h3>Convergence</h3>
<p>Common to all of these methods is the way that PRISM checks convergence, i.e. decides when to terminate the iterative methods because the answers have converged sufficiently. This is done by checking when the maximum difference between elements in the solution vectors from successive iterations drops below a given threshold. The default value for this threshold is 10<sup>-6</sup> but it can be altered with the "Termination epsilon" option (switch <code>-epsilon &lt;val&gt;</code>). The way that the maximum difference is computed can also be varied:
either "relative" or "absolute" (the default is "relative"). This can be changed using the "Termination criteria" option (command-line switches <code>-relative</code> and <code>-absolute</code>, or <code>-rel</code> and <code>-abs</code> for short).
</p>
<p class='vspace'>Also, the maximum number of iterations performed is given an upper limit
in order to trap the cases when computation will not converge.
The default limit is 10,000 but can be changed with the "Termination max. iterations" option (switch <code>-maxiters &lt;val&gt;</code>). Computations that reach this upper limit will trigger an error during model checking to alert the user to this fact.
</p>
<p class='vspace'>For the specific case of "steady-state convergence checking" during uniformisation (which is an optimisation for uniformisation), convergence checking can be disabled with the "Use steady-state detection" option (command-line switch <code>-nossdetect</code>).
</p>
<div class='vspace'></div><h3>Linear equation systems</h3>
<p>For instances where PRISM has to solve a linear equation system (see above), the numerical method used can be selected by the user. Below is a list of the alternatives available and the switches used to select them from the command-line. The corresponding GUI option is "Iterative method".
</p>
<div class='vspace'></div><ul><li>Power method: <code>-power</code> (or <code>-pow</code>, <code>-pwr</code>)
</li><li>Jacobi method: <code>-jacobi</code> (or <code>-jac</code>)
</li><li>Gauss-Seidel method: <code>-gaussseidel</code> (or <code>-gs</code>)
</li><li>Backwards Gauss-Seidel method: <code>-bgaussseidel</code> (or <code>-bgs</code>)
</li><li>JOR method (Jacobi with over-relaxation): <code>-jor</code>
</li><li>SOR method: <code>-sor</code>
</li><li>Backwards SOR method: <code>-bsor</code>
</li></ul><p class='vspace'>When using the MTBDD engine, Gauss-Seidel/SOR based methods are not available. When using the hybrid engine, <em>pseudo</em> variants of Gauss-Seidel/SOR based method can also be used [<a class='wikilink' href='References.html#Par02'>Par02</a>] (type <code>prism -help</code> at the command-line for details of the corresponding switches). For methods which use over-relaxation (JOR/SOR), the over-relaxation parameter (between 0.0 and 2.0) can also be specified with option "Over-relaxation parameter" (switch <code>-omega &lt;val&gt;</code>).
</p>
<div class='vspace'></div><h3>More information</h3>
<p>For more information about all the issues discussed in this section, see e.g. [<a class='wikilink' href='References.html#Ste94'>Ste94</a>].
</p><hr />
<h1>Other Options</h1>
<h3>Output options</h3>
<p>To increase the amount of information displayed by PRISM (in particular, to display lists of states and probability vectors), you can use the "Verbose output" option (activated with comand-line switch <code>-verbose</code> or <code>-v</code>). To display additional statistics about MTBDDs after model construction, use the "Extra MTBDD information" option (switch <code>-extraddinfo</code>) and, to view MTBDD sizes during the process of reachability, use option "Extra reachability information" (switch <code>-extrareachinfo</code>).
</p>
<div class='vspace'></div><h3>Fairness</h3>
<p>Sometimes, model checking of properties for MDPs requires fairness constraints to be taken into account.
See e.g. [<a class='wikilink' href='References.html#BK98'>BK98</a>],[<a class='wikilink' href='References.html#Bai98'>Bai98</a>] for more information.
To enable the use of fairness constraints (for <code><strong>P</strong></code> operator properties), use the <code>-fair</code> switch.
</p>
<div class='vspace'></div><h3>Probability/rate checks</h3>
<p>By default, when constructing a model, PRISM checks that all probabilities and rates are within acceptable ranges (i.e. are between 0 and 1, or are non-negative, respectively). For DTMCs and MDPs, it also checks that the probabilities sum up to one for each command. These checks are often very useful for highlighting user modelling errors and it is strongly recommended that you keep them enabled, however if you need to disable them you can do so via option "do prob checks?" in the GUI or command-line switch <code>-noprobchecks</code>.
</p>
<div class='vspace'></div><h3>CUDD memory</h3>
<p>CUDD, the underlying BDD and MTBDD library used in PRISM has an upper memory limit.
By default, this limit is 204800 KB (200 MB).
If you are working on a machine with significantly more memory this and PRISM runs out of memory when model checking, this may help.
To set the limit (in KB) from the command-line, use the <code>-cuddmaxmem val</code> switch.
You can also change this setting in the GUI, but you will need to close and restart the GUI (saving the settings as you do) for this option to take effect.
</p>
<div class='vspace'></div><h3>Java memory</h3>
<p>The Java virtual machine (JVM) used to execute PRISM also has un upper memory limit.
Sometimes (for example if you are trying to load a model for which the PRISM code is extremely lengthy),
this limit will be exceeded and you will see an error of the form <code>java.lang.OutOfMemory</code>.
The current default limit for the Sun JVM is 64MB.
To resolve this problem, you can increase this memory limit.
On Unix, Linux or Mac OS X platforms, this is done by setting the environment variable PRISM_JAVAMAXMEM, for example (under a <code>tcsh</code> shell):
</p>
<div class='vspace'></div><pre class='escaped'>
setenv PRISM_JAVAMAXMEM 512m
prism big_model.pm
</pre>
<p class='vspace'>or (under a <code>bash</code> shell):
</p>
<div class='vspace'></div><pre class='escaped'>
PRISM_JAVAMAXMEM=512m
export PRISM_JAVAMAXMEM
prism big_model.pm
</pre>
<p class='vspace'>The lower case <code>m</code> in <code>512m</code> denotes MB.
If you are running PRISM on Windows you will have to do this manually by modifying the <code>prism.bat</code> or <code>xprism.bat</code> scripts.
To set the memory to 512MB for example, replace <code>java</code> at the start of the last line in the appropriate script with <code>java -Xmx512m</code>.
</p>
<div class='vspace'></div><h3>Precomputation</h3>
<p>By default, PRISM's probabilistic model checking algorithms use an initial <em>precomputation</em>
step which uses graph-based techniques to efficient detect trivial cases where probabilities are 0 or 1.
Occasionally, you may want to disable this step for efficiency (e.g. if you know that there are no/few such states and the precomputation process is slow). This can be done with the <code>-nopre</code> switch. Please note that it is not always safe to disable precomputation: unless you are checking until properties on MDPs or on DTMCs using the Power method (which is not the default option), then you should only only disable precomputation if you know that it will not identify any states which (non-trivially) have probability 0 or 1.
</p>
<p class='vspace'><br /><br />
</p><hr />
<h1><span class='big'>References</span></h1>
<hr />
<div class="latex2html">
<DL COMPACT><DD><P></P><DT><A NAME="AH99">AH99</A>
<DD>
R.&nbsp;Alur and T.&nbsp;Henzinger.
<BR>Reactive modules.
<BR><EM>Formal Methods in System Design</EM>, 15(1):7-48, 1999.

<P></P><DT><A NAME="ASSB96">ASSB96</A>
<DD>
A.&nbsp;Aziz, K.&nbsp;Sanwal, V.&nbsp;Singhal, and R.&nbsp;Brayton.
<BR>Verifying continuous time Markov chains.
<BR>In R.&nbsp;Alur and T.&nbsp;Henzinger, editors, <EM>Proc. 8th International
  Conference on Computer Aided Verification (CAV'96)</EM>, volume 1102 of <EM>  LNCS</EM>, pages 269-276. Springer, 1996.

<P></P><DT><A NAME="Bai98">Bai98</A>
<DD>
C.&nbsp;Baier.
<BR>On algorithmic verification methods for probabilistic systems, 1998.
<BR>Habilitation thesis, Fakult&#228;t f&#252;r Mathematik &amp; Informatik,
  Universit&#228;t Mannheim.

<P></P><DT><A NAME="BKH99">BKH99</A>
<DD>
C.&nbsp;Baier, J.-P. Katoen, and H.&nbsp;Hermanns.
<BR>Approximate symbolic model checking of continuous-time Markov
  chains.
<BR>In J.&nbsp;Baeten and S.&nbsp;Mauw, editors, <EM>Proc. 10th International
  Conference on Concurrency Theory (CONCUR'99)</EM>, volume 1664 of <EM>LNCS</EM>,
  pages 146-161. Springer, 1999.

<P></P><DT><A NAME="BK98">BK98</A>
<DD>
C.&nbsp;Baier and M.&nbsp;Kwiatkowska.
<BR>Model checking for a probabilistic branching time logic with
  fairness.
<BR><EM>Distributed Computing</EM>, 11(3):125-155, 1998.

<P></P><DT><A NAME="BdA95">BdA95</A>
<DD>
A.&nbsp;Bianco and L.&nbsp;de&nbsp;Alfaro.
<BR>Model checking of probabilistic and nondeterministic systems.
<BR>In P.&nbsp;Thiagarajan, editor, <EM>Proc. 15th Conference on Foundations
  of Software Technology and Theoretical Computer Science</EM>, volume 1026 of
  <EM>LNCS</EM>, pages 499-513. Springer, 1995.

<P></P><DT><A NAME="HJ94">HJ94</A>
<DD>
H.&nbsp;Hansson and B.&nbsp;Jonsson.
<BR>A logic for reasoning about time and reliability.
<BR><EM>Formal Aspects of Computing</EM>, 6(5):512-535, 1994.

<P></P><DT><A NAME="HLMP04">HLMP04</A>
<DD>
T.&nbsp;H&#233;rault, R.&nbsp;Lassaigne, F.&nbsp;Magniette, and S.&nbsp;Peyronnet.
<BR>Approximate probabilistic model checking.
<BR>In <EM>Proc. 5th International Conference on Verification, Model
  Checking and Abstract Interpretation (VMCAI'04)</EM>, volume 2937 of <EM>  LNCS</EM>. Springer, 2004.

<P></P><DT><A NAME="HKN+03">HKN+03</A>
<DD>
H.&nbsp;Hermanns, M.&nbsp;Kwiatkowska, G.&nbsp;Norman, D.&nbsp;Parker, and M.&nbsp;Siegle.
<BR>On the use of MTBDDs for performability analysis and verification
  of stochastic systems.
<BR><EM>Journal of Logic and Algebraic Programming: Special Issue on
  Probabilistic Techniques for the Design and Analysis of Systems</EM>,
  56(1-2):23-67, 2003.

<P></P><DT><A NAME="Hil96">Hil96</A>
<DD>
J.&nbsp;Hillston.
<BR><EM>A Compositional Approach to Performance Modelling</EM>.
<BR>Cambridge University Press, 1996.

<P></P><DT><A NAME="KSK66">KSK66</A>
<DD>
J.&nbsp;Kemeny, J.&nbsp;Snell, and A.&nbsp;Knapp.
<BR><EM>Denumerable Markov Chains</EM>.
<BR>D. Van Nostrand Company, 1966.

<P></P><DT><A NAME="KNP04b">KNP04b</A>
<DD>
M.&nbsp;Kwiatkowska, G.&nbsp;Norman, and D.&nbsp;Parker.
<BR>Probabilistic symbolic model checking with PRISM: A hybrid
  approach.
<BR><EM>International Journal on Software Tools for Technology Transfer
  (STTT)</EM>, 6(2):128-142, 2004.

<P></P><DT><A NAME="KNP07a">KNP07a</A>
<DD>
M.&nbsp;Kwiatkowska, G.&nbsp;Norman, and D.&nbsp;Parker.
<BR>Stochastic model checking.
<BR>In M.&nbsp;Bernardo and J.&nbsp;Hillston, editors, <EM>Formal Methods for the
  Design of Computer, Communication and Software Systems: Performance
  Evaluation (SFM'07)</EM>, volume 4486 of <EM>LNCS (Tutorial Volume)</EM>, pages
  220-270. Springer, 2007.

<P></P><DT><A NAME="Par02">Par02</A>
<DD>
D.&nbsp;Parker.
<BR><EM>Implementation of Symbolic Model Checking for Probabilistic
  Systems</EM>.
<BR>Ph.D. thesis, University of Birmingham, 2002.

<P></P><DT><A NAME="Ste94">Ste94</A>
<DD>
W.&nbsp;J. Stewart.
<BR><EM>Introduction to the Numerical Solution of Markov Chains</EM>.
<BR>Princeton, 1994.
</DL>
</div>

<p><br /><br />
</p>
</div>


<!--PageFooterFmt-->
  <div id='prism-man-footer'>
  </div>
<!--/PageFooterFmt-->


<!-- ============================================================================= -->

</div> <!-- id="prism-mainbox" -->

</div> <!-- id="layout-main" -->
</div> <!-- id="layout-maincontainer" -->

<div id="layout-leftcol">
<div id="prism-navbar2">

<h3><a class='wikilink' href='Welcome.html'>PRISM Manual</a></h3>
<ul><li><a class='wikilink' href='Contents.html'>Contents</a>
</li><li><a class='wikilink' href='Introduction.html'>Introduction</a>
</li><li><a class='wikilink' href='../InstallingPRISM/Instructions.html'>Installing PRISM</a>
</li><li><a class='wikilink' href='../ThePRISMLanguage/Introduction.html'>The PRISM Language</a>
</li><li><a class='wikilink' href='../PropertySpecification/Introduction.html'>Property Specification</a>
</li><li><a class='wikilink' href='../RunningPRISM/StartingPRISM.html'>Running PRISM</a>
</li><li><a class='wikilink' href='../ConfiguringPRISM/Introduction.html'>Configuring PRISM</a>
</li><li><a class='wikilink' href='References.html'>References</a>
</li><li><a class='wikilink' href='../FrequentlyAskedQuestions/Main.html'>FAQ</a>
</li></ul><p>[ <a class='selflink' href='AllOnOnePage.html'>View all</a> ]
</p>


</div>  <!-- id="prism-navbar2" -->
</div> <!-- id="layout-leftcol" -->

</body>
</html>

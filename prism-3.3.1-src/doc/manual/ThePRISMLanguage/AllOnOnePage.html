<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
"http://www.w3.org/TR/html4/loose.dtd">

<html>
<head>

<title>
PRISM Manual | ThePRISMLanguage / AllOnOnePage 
</title>

<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="keywords" content="prism, probabilistic, symbolic, model, checker, verification, birmingham, oxford, parker, norman, kwiatkowska">

<link rel="icon" href="../pub/skins/offline/images/p16.ico" type="image/x-icon">
<link rel="shortcut icon" href="../pub/skins/offline/images/p16.ico" type="image/x-icon">

<!--HTMLHeader--><style type='text/css'><!--
  ul, ol, pre, dl, p { margin-top:0px; margin-bottom:0px; }
  code.escaped { white-space: nowrap; }
  .vspace { margin-top:1.33em; }
  .indent { margin-left:40px; }
  .outdent { margin-left:40px; text-indent:-40px; }
  a.createlinktext { text-decoration:none; border-bottom:1px dotted gray; }
  a.createlink { text-decoration:none; position:relative; top:-0.5em;
    font-weight:bold; font-size:smaller; border-bottom:none; }
  img { border:0px; }
  
.sourceblocklink {
  text-align: right;
  font-size: smaller;
}
.sourceblocktext {
  padding: 0.5em;
  border: 1px solid #808080;
  background-color: #F1F0ED;
}
.sourceblocktext div {
  font-family: monospace;
  font-size: small;
  line-height: 1.0;
  height: 1%;
}
.sourceblocktext div.head,
.sourceblocktext div.foot {
  font: italic medium serif;
  padding: 0.5em;
}
.codeblocklink {
  text-align: right;
  font-size: smaller;
}
.codeblocktext {
  text-align: left;
  padding: 0.5em;
  border: 1px solid #808080;
  background-color: #F1F0ED;
}
.codeblocktext pre {
  font-family: monospace;
  font-size: small;
  line-height: 1.0;
}.editconflict { color:green; 
  font-style:italic; margin-top:1.33em; margin-bottom:1.33em; }

  table.markup { border:2px dotted #ccf; width:90%; }
  td.markup1, td.markup2 { padding-left:10px; padding-right:10px; }
  table.vert td.markup1 { border-bottom:1px solid #ccf; }
  table.horiz td.markup1 { width:23em; border-right:1px solid #ccf; }
  table.markup caption { text-align:left; }
  div.faq p, div.faq pre { margin-left:2em; }
  div.faq p.question { margin:1em 0 0.75em 0; font-weight:bold; }
   
    .frame 
      { border:1px solid #cccccc; padding:4px; background-color:#f9f9f9; }
    .lfloat { float:left; margin-right:0.5em; }
    .rfloat { float:right; margin-left:0.5em; }
a.varlink { text-decoration:none; }

--></style>  <meta name='robots' content='index,follow' />


<link type="text/css" rel="stylesheet" href="../pub/skins/offline/css/base.css">
<link type="text/css" rel="stylesheet" href="../pub/skins/offline/css/prism.css">
<link type="text/css" rel="stylesheet" href="../pub/skins/offline/css/prismmanual.css">

</head>

<body text="#000000" bgcolor="#ffffff">

<div id="layout-maincontainer">
<div id="layout-main">

<div id="prism-mainbox">

<!-- ============================================================================= -->

<!--PageHeaderFmt-->
<!--/PageHeaderFmt-->

<!--PageTitleFmt--><!--PageText-->
<div id='wikitext'>
<div class='vspace'></div><h1><span class='big'>The PRISM Language</span></h1>
<hr />
<h1>Introduction</h1>
<p>In order to construct and analyse a model with PRISM,
it must be specified in the PRISM language,
a simple, state-based language,
based on the Reactive Modules formalism of Alur and Henzinger [<a class='wikilink' href='../Main/References.html#AH99'>AH99</a>].
In this section, we describe the PRISM language and present a number of small illustrative examples.
A precise definition of the semantics of the language is available from the "<a class='urllink' href='http://www.prismmodelchecker.org/doc/'>Documentation</a>" section of the PRISM web site. One of the best ways to learn what can be done with the PRISM language is to look at some existing examples.
A number of these are included with the tool distribution in the <code>examples</code> directory.
Many additional examples can be found on the "<a class='urllink' href='http://www.prismmodelchecker.org/casestudies/'>Case Studies</a>" section of the <a class='urllink' href='http://www.prismmodelchecker.org/'>PRISM website</a>.
</p>
<p class='vspace'>The fundamental components of the PRISM language are <em>modules</em> and <em>variables</em>.
A model is composed of a number of <em>modules</em> which can interact with each other.
A module contains a number of local <em>variables</em>.
The values of these variables at any given time constitute the state of the module.
The <em>global state</em> of the whole model is determined by the <em>local state</em> of all modules.
The behaviour of each module is described by a set of <em>commands</em>.
A command takes the form:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">guard</span> -&gt; <span class="prismident">prob_1</span> : <span class="prismident">update_1</span> + ... + <span class="prismident">prob_n</span> : <span class="prismident">update_n</span>;<br/>
</div></div>
</div>
<p class='vspace'>The <em>guard</em> is a predicate over all the variables in the model (including those belonging to other modules). Each <em>update</em> describes a transition which the module can make if the guard is true. A transition is specified by giving the new values of the variables in the module, possibly as a function of other variables. Each update is also assigned a probability (or in some cases a rate) which will be assigned to the corresponding transition.
</p><hr />
<h1>Example 1</h1>
<p>We will use the following simple example to illustrate the basic concepts of the PRISM language.
Consider a system comprising two identical processes which must operate under mutual exclusion.
Each process can be in one of 3 states: {0,1,2}.
From state 0, a process will move to state 1 with probability 0.2
and remain in the same state with probability 0.8.
From state 1, it tries to move to the critical section: state 2.
This can only occur if the other process is not in its critical section.
Finally, from state 2, a process will either remain there or move back to state 0
with equal probability.
The PRISM code to describe this system can be seen below.
In the next sections, we explain each aspect of the code in turn.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismcomment">// Example 1</span><br/>
<span class="prismcomment">// Two process mutual exclusion</span><br/>
<br/>
<span class="prismkeyword">mdp</span><br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">M1</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span> : [<span class="prismnum">0</span>..<span class="prismnum">2</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">x</span>=<span class="prismnum">1</span> &amp; <span class="prismident">y</span>!=<span class="prismnum">2</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">x</span>=<span class="prismnum">2</span> -&gt; <span class="prismnum">0.5</span>:(<span class="prismident">x</span>'=<span class="prismnum">2</span>) + <span class="prismnum">0.5</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">M2</span><br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">y</span> : [<span class="prismnum">0</span>..<span class="prismnum">2</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">y</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">y</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">y</span>'=<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">y</span>=<span class="prismnum">1</span> &amp; <span class="prismident">x</span>!=<span class="prismnum">2</span> -&gt; (<span class="prismident">y</span>'=<span class="prismnum">2</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">y</span>=<span class="prismnum">2</span> -&gt; <span class="prismnum">0.5</span>:(<span class="prismident">y</span>'=<span class="prismnum">2</span>) + <span class="prismnum">0.5</span>:(<span class="prismident">y</span>'=<span class="prismnum">0</span>);<br/>
<br/>
<span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'  style='text-align: center;'><strong>The PRISM Language: Example 1</strong>
</p><hr />
<h1>Model Type</h1>
<p>The PRISM language can be used to describe three types of probabilistic models:
discrete-time Markov chains (DTMCs), continuous-time Markov chains (CTMCs)
and Markov decision processes (MDPs).
To indicate which type is being described, a PRISM model includes one of the keywords
<code><strong>dtmc</strong></code>, <code><strong>ctmc</strong></code> or <code><strong>mdp</strong></code>.
This is typically at the very start of the file (as in <a class='wikilink' href='Example1.html'>Example 1</a>),
but can actually occur anywhere in the file (except inside modules and other declarations).
The keywords <code><strong>probabilistic</strong></code>, <code><strong>stochastic</strong></code> and <code><strong>nondeterministic</strong></code>
can be used as alternatives for <code><strong>dtmc</strong></code>, <code><strong>dtmc</strong></code> and <code><strong>mdp</strong></code>, respectively.
If no such model type declaration is included, the model is by default assumed to be an MDP.
</p>
<div class='vspace'></div><hr />
<h1>Modules And Variables</h1>
<p>The <a class='wikilink' href='Example1.html'>previous example</a> uses two modules, <code>M1</code> and <code>M2</code>, one representing each process.
A module is specified as:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">module</span> <span class="prismident">name</span> ... <span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'>The definition of a module contains two parts: its variables and its guards.
In this example, each module has one integer variable with range <code>[0..2]</code>.
A variable declaration looks like:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismident">x</span> : [<span class="prismnum">0</span>..<span class="prismnum">2</span>] <span class="prismkeyword">init</span> <span class="prismnum">0</span>;<br/>
</div></div>
</div>
<p class='vspace'>Notice that the initial value of the variable is also specified.
See the next subsection for more information about this subject.
Boolean variables can also be used, e.g.:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismident">b</span> : <span class="prismkeyword">bool</span> <span class="prismkeyword">init</span> <span class="prismkeyword">false</span>;<br/>
</div></div>
</div>
<p class='vspace'>The names given to modules and variables are referred to as <em>identifiers</em>.
Identifiers can be made up of letters, digits and the underscore character, but cannot begin with a digit,
i.e. they must satisfy the regular expression [A-Za-z_][A-Za-z0-9_]*, and are case-sensitive.
Furthermore, identifiers cannot be any of the following, which are all reserved keywords in PRISM:
<code><strong>A</strong></code>, <code><strong>bool</strong></code>, <code><strong>const</strong></code>, <code><strong>ctmc</strong></code>, <code><strong>C</strong></code>, <code><strong>double</strong></code>, <code><strong>dtmc</strong></code>, <code><strong>E</strong></code>, <code><strong>endinit</strong></code>, <code><strong>endmodule</strong></code>, <code><strong>endrewards</strong></code>, <code><strong>endsystem</strong></code>, <code><strong>false</strong></code>, <code><strong>formula</strong></code>, <code><strong>func</strong></code>, <code><strong>F</strong></code>, <code><strong>global</strong></code>, <code><strong>G</strong></code>, <code><strong>init</strong></code>, <code><strong>I</strong></code>, <code><strong>int</strong></code>, <code><strong>label</strong></code>, <code><strong>max</strong></code>, <code><strong>mdp</strong></code>, <code><strong>min</strong></code>, <code><strong>module</strong></code>, <code><strong>X</strong></code>, <code><strong>nondeterministic</strong></code>, <code><strong>Pmax</strong></code>, <code><strong>Pmin</strong></code>, <code><strong>P</strong></code>, <code><strong>probabilistic</strong></code>, <code><strong>prob</strong></code>, <code><strong>rate</strong></code>, <code><strong>rewards</strong></code>, <code><strong>Rmax</strong></code>, <code><strong>Rmin</strong></code>, <code><strong>R</strong></code>, <code><strong>S</strong></code>, <code><strong>stochastic</strong></code>, <code><strong>system</strong></code>, <code><strong>true</strong></code>, <code><strong>U</strong></code>, <code><strong>W</strong></code>, 
</p><hr />
<h1>Initial States</h1>
<p>The state space of a probabilistic model described in the PRISM language
is the set of all possible valuations of its variables.
The set of initial states of the model can be specified in one of two ways.
The most common approach is simply to specify an initial value for each variable in the model.
This is done in the declaration of each variable, as illustrated in <a class='wikilink' href='Example1.html'>Example 1</a>
and as discussed in the previous section.
If the initial value of a variable is omitted from its declaration,
it is taken to be the minimum value of the variable's range.
</p>
<p class='vspace'>This approach results in a single initial state.
It is also possible to construct a model with multiple initial states.
This is done using the <code><strong>init</strong>...<strong>endinit</strong></code> construct,
which can be placed anywhere in the file except within a module definition,
and removing any initial values from variable declarations.
Between the <code><strong>init</strong></code> and <code><strong>endinit</strong></code> keywords, there should be a
predicate over all the variables of the model.
Any state which satisfies this predicate is an initial state.
</p>
<p class='vspace'>Consider <a class='wikilink' href='Example1.html'>Example 1</a>.
As it stands, there is a single initial state <code>(0,0)</code> (i.e.  <code>x=0</code> and <code>y=0</code>).
If we remove the <code><strong>init</strong> 0</code> part of both variable declarations
and add the following to the end of the file:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">init</span> <span class="prismident">x</span>=<span class="prismnum">0</span> <span class="prismkeyword">endinit</span><br/>
</div></div>
</div>
<p class='vspace'>there will be three initial states: <code>(0,0)</code>, <code>(0,1)</code> and <code>(0,2)</code>.
Similarly, we could instead add:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">init</span> <span class="prismident">x</span>+<span class="prismident">y</span>=<span class="prismnum">1</span> <span class="prismkeyword">endinit</span><br/>
</div></div>
</div>
<p class='vspace'>in which case there would be two initial states: <code>(0,1)</code> and <code>(1,0)</code>.
</p><hr />
<h1>Commands</h1>
<p>The behaviour of each module is described by commands, comprising a guard and one or more updates.
The first command of module <code>M1</code> in our example is:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>The guard <code>x=0</code> indicates that this describes the behaviour of the module when the variable <code>x</code> has value 0.
The updates <code>(x'=0)</code> and <code>(x'=1)</code> and their associated probabilities state that the value of <code>x</code> will
remain at 0 with probability 0.8 and change to 1 with probability 0.2.
For DTMCs and MDPs, we require that the probabilities on the right hand side of a command sum to one.
Note that the inclusion of updates in parentheses, e.g. <code>(x'=1)</code>, is essential.
While older versions of PRISM did not report the absence of parentheses as an error, newer versions do.
</p>
<p class='vspace'>The second command:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">1</span> &amp; <span class="prismident">y</span>!=<span class="prismnum">2</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">2</span>);<br/>
</div></div>
</div>
<p class='vspace'>illustrates that guards can contain constraints on any variable, not just the ones in that module,
i.e. the behaviour of one module can depend on the state of another.
Updates, however, can only specify values for variables belonging to the module.
The command above also shows that, when there is a single update with probability 1, the <code>1.0:</code> can be omitted.
</p>
<p class='vspace'>If a module has more than one variable, updates describe the new value for each of them.
For example, if it had two variables <code>x1</code> and <code>x2</code>, a possible command would be:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x1</span>=<span class="prismnum">0</span> &amp; <span class="prismident">x2</span>&gt;<span class="prismnum">0</span> -&gt; <span class="prismnum">0.5</span>:(<span class="prismident">x1</span>'=<span class="prismnum">1</span>)&amp;(<span class="prismident">x2</span>'=<span class="prismident">x2</span>+<span class="prismnum">1</span>) + <span class="prismnum">0.5</span>:(<span class="prismident">x1</span>'=<span class="prismnum">2</span>)&amp;(<span class="prismident">x2</span>'=<span class="prismident">x2</span>-<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>Notice that elements of the updates are concatenated with <code>&amp;</code> and that each element must be bracketed individually.
If an update does not give a new value for a local variable, it is assumed not to change.
As a special case, the keyword <code><strong>true</strong></code> can be used to denote an update where no variable's value changes.
</p><hr />
<h1>Parallel Composition</h1>
<p>The probabilistic model corresponding to a PRISM language description is constructed as the parallel composition of its modules.
In every state of the model, there is a set of commands (belonging to any of the modules) which are enabled,
i.e. whose guards are satisfied in that state.
The choice between which command is performed (i.e. the scheduling) depends on the model type.
For an MDP, as in Example 1, the choice is <em>nondeterministic</em>.
By way of example, consider state <code>(0,0)</code> (i.e.  <code>x=0</code> and <code>y=0</code>).
In the MDP, there would be a nondeterministic choice between two probability distributions:
</p>
<div class='vspace'></div><ul><li><code>0.8:(0,0) + 0.2:(1,0)</code> (module <code>M1</code> moves)
</li><li><code>0.8:(0,0) + 0.2:(0,1)</code> (module <code>M2</code> moves)
</li></ul><p class='vspace'>For a DTMC, the choice is <em>probabilistic</em>: each enabled command is selected with equal probability.
If Example 1 was a DTMC, then in state <code>(0,0)</code> of the model
the following probability distribution would result:
</p>
<div class='vspace'></div><ul><li><code>0.8:(0,0) + 0.1:(1,0) + 0.1:(0,1)</code>
</li></ul><p class='vspace'>For a CTMC, the choice is modelled as a "race" between transitions.
</p><hr />
<h1>Local Nondeterminism</h1>
<p>PRISM models which are MDPs can also exhibit <em>local nondeterminism</em>,
which allows the modules themselves to make nondeterministic choices.
In Example 1, we can make the probabilistic choice in the first state of module <code>M1</code> nondeterministic by replacing the command:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">0.8</span>:(<span class="prismident">x</span>'=<span class="prismnum">0</span>) + <span class="prismnum">0.2</span>:(<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>with the commands:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">0</span>);<br/>
[] <span class="prismident">x</span>=<span class="prismnum">0</span> -&gt; (<span class="prismident">x</span>'=<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>Assuming we do the same for module <code>M2</code>, in state <code>(0,0)</code> of the MDP
there will be a nondeterministic choice between three (trivial) probability distributions:
</p>
<div class='vspace'></div><ul><li><code>1.0:(0,0)</code>
</li><li><code>1.0:(1,0)</code>
</li><li><code>1.0:(0,1)</code>
</li></ul><p class='vspace'>PRISM also permits local nondeterminism in models which are DTMCs,
although the nondeterministic choice is randomised when the parallel composition of the modules occurs.
Since the appearance of nondeterminism in a DTMC is often the result of
a user error in the model specification, PRISM displays a warning when local nondeterminism is detected in a DTMC.
</p><hr />
<h1>Module Renaming</h1>
<p>PRISM also supports <em>module renaming</em>, which allows duplication of modules.
In Example 1, module <code>M2</code> is identical to module <code>M1</code> so we can in fact replace its entire definition with:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">module</span> <span class="prismident">M2</span> = <span class="prismident">M1</span> [ <span class="prismident">x</span>=<span class="prismident">y</span>, <span class="prismident">y</span>=<span class="prismident">x</span> ] <span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'>Note that this renaming is done at a textual level, so any identifiers (including <a class='wikilink' href='Synchronisation.html'>action labels</a>, <a class='wikilink' href='Constants.html'>constants</a> and <a class='wikilink' href='Expressions.html'>functions</a>)
used in the module definition can be changed in this way.
All of the variables in the module being renamed (in this case, just <code>x</code>) must be renamed to new, unused names.
</p><hr />
<h1>Example 2</h1>
<p>We now introduce a second example, which is a model of an <em>N</em>-place queue of jobs and
a server which removes jobs from the queue and processes them.
The PRISM code can be found below.
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismcomment">// Example 2</span><br/>
<span class="prismcomment">// N-place queue + server</span><br/>
<br/>
<span class="prismkeyword">ctmc</span><br/>
<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">N</span> = <span class="prismnum">10</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">mu</span> = <span class="prismnum">1</span>/<span class="prismnum">10</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">lambda</span> = <span class="prismnum">1</span>/<span class="prismnum">2</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">gamma</span> = <span class="prismnum">1</span>/<span class="prismnum">3</span>;<br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">queue</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">q</span> : [<span class="prismnum">0</span>..<span class="prismident">N</span>];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">q</span>&lt;<span class="prismident">N</span> -&gt; <span class="prismident">mu</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>+<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">q</span>=<span class="prismident">N</span> -&gt; <span class="prismident">mu</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">serve</span>] <span class="prismident">q</span>&gt;<span class="prismnum">0</span> -&gt; <span class="prismident">lambda</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>-<span class="prismnum">1</span>);<br/>
<span class="prismkeyword">endmodule</span><br/>
<br/>
<span class="prismkeyword">module</span> <span class="prismident">server</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">s</span> : [<span class="prismnum">0</span>..<span class="prismnum">1</span>];<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">serve</span>] <span class="prismident">s</span>=<span class="prismnum">0</span> -&gt; <span class="prismnum">1</span>:(<span class="prismident">s</span>'=<span class="prismnum">1</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismident">s</span>=<span class="prismnum">1</span> -&gt; <span class="prismident">gamma</span>:(<span class="prismident">s</span>'=<span class="prismnum">0</span>);<br/>
<span class="prismkeyword">endmodule</span><br/>
</div></div>
</div>
<p class='vspace'  style='text-align: center;'><strong>The PRISM Language: Example 2</strong>
</p>
<p class='vspace'>As can be seen from the start of the file,
the model is a continuous-time Markov chain (CTMC).
One of the main differences, therefore, is that transitions of modules are
labelled with (positive-valued) <em>rates</em>, rather than probabilities.
The notation used in commands, however, to associate rates to transitions is identical to
that used to assign probabilities in DTMCs and MDPs:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismident">rate_1</span>:<span class="prismident">update_1</span> + <span class="prismident">rate_2</span>:<span class="prismident">update_2</span> + ...<br/>
</div></div>
</div>
<p class='vspace'>Example 2 also introduces a number of other PRISM language concepts:
constants, action labels and synchronisation.
These are described in the following sections.
</p><hr />
<h1>Constants</h1>
<p>PRISM also supports the use of <em>constants</em>, as seen in <a class='wikilink' href='Example2.html'>Example 2</a>.
Constants can be integers, doubles or Booleans
and can be defined using literal values or as constant expressions (including in terms of each other) using the <code><strong>const</strong></code>
keyword. For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">const</span> <span class="prismkeyword">int</span> <span class="prismident">radius</span> = <span class="prismnum">12</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">pi</span> = <span class="prismnum">3.141592</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">double</span> <span class="prismident">area</span> = <span class="prismident">pi</span> * <span class="prismident">radius</span> * <span class="prismident">radius</span>;<br/>
<span class="prismkeyword">const</span> <span class="prismkeyword">bool</span> <span class="prismident">yes</span> = <span class="prismkeyword">true</span>;<br/>
</div></div>
</div>
<p class='vspace'>The identifiers used for their names are subject to the same rules as <a class='wikilink' href='ModulesAndVariables.html'>variables</a>.
</p>
<p class='vspace'>Constants can be used anywhere that a constant value would be expected,
such as the lower or upper range of a variable (e.g. <code>N</code> in Example 2),
the probability or rate associated with an update (<code>mu</code> in Example 2),
or anywhere in a guard or update.
As will be described later constants can also be left undefined
and specified later, either to a single value or a range of values, using <a class='wikilink' href='../RunningPRISM/Experiments.html'>experiments</a>.
</p>
<p class='vspace'><strong>Note:</strong> For the sake of backward-compatibility, the notation used in earlier versions of PRISM
(<code><strong>const</strong></code> for <code><strong>const int</strong></code> and <code><strong>rate</strong></code> or <code><strong>prob</strong></code> for <code><strong>const double</strong></code>) is still supported.
</p><hr />
<h1>Expressions</h1>
<p>The definition of the <code>area</code> constant, in the example above, uses an <em>expression</em>.
We now define more precisely what types of expression are supported by PRISM.
Expressions can contain literal values (12, 3.141592, <code><strong>true</strong></code>, <code><strong>false</strong></code>, etc.),
identifiers (corresponding to variables, constants, etc.) and operators from the following list:
</p>
<div class='vspace'></div><ul><li><code>-</code> (unary minus)
</li><li><code>*</code>, <code>/</code> (multiplication, division)
</li><li><code>+</code>, <code>-</code> (addition, subtraction)
</li><li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code> (relational operators)
</li><li><code>=</code>, <code>!=</code> (equality operators)
</li><li><code>!</code> (negation)
</li><li><code>&amp;</code> (conjunction)
</li><li><code>|</code> (disjunction)
</li><li><code>=&gt;</code> (implication)
</li><li><code>?</code> (condition evaluation: <code>condition ? a : b</code> means "if <code>condition</code> is true then <code>a</code> else <code>b</code>")
</li></ul><p class='vspace'>All of these operators except <code>?</code> are left associative
(i.e. they are evaluated from left to right).
The precedence of the operators is as found in the list above,
most strongly binding operators first.
Operators on the same line (e.g. <code>+</code> and <code>-</code>) are of equal precedence.
</p>
<p class='vspace'>The notation for expressions is hence essentially equivalent to that of C/C++ or Java.
One notable exception to this is that  the division operator <code>/</code> always performs floating point, not integer, division,
i.e. the result of <code>22/7</code> is 3.142857... not 3.
All expressions must evaluate correctly in terms of type (integer, double or Boolean).
</p>
<p class='vspace'><strong>Built-in Functions</strong>
</p>
<p class='vspace'>Expressions can make use of several built-in functions:
</p>
<div class='vspace'></div><ul><li><code>min(...)</code> and <code>max(...)</code>, which select the minimum and maximum value, respectively, of two or more numbers;
</li><li><code>floor(x)</code> and <code>ceil(x)</code>, which round <code>x</code> down and up, respectively, to the nearest integer;
</li><li><code>pow(x,y)</code> which computes <code>x</code> to the power of <code>y</code>;
</li><li><code>mod(i,n)</code> for integer modulo operations;
</li><li><code>log(x,b)</code>, which computes the logarithm of <code>x</code> to base <code>b</code>.
</li></ul><p class='vspace'>Examples of their usage are:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">min</span>(<span class="prismident">x</span>+<span class="prismnum">1</span>, <span class="prismident">x_max</span>)<br/>
<span class="prismkeyword">max</span>(<span class="prismident">a</span>,<span class="prismident">b</span>,<span class="prismident">c</span>)<br/>
<span class="prismident">floor</span>(<span class="prismnum">13.5</span>)<br/>
<span class="prismident">ceil</span>(<span class="prismnum">13.5</span>)<br/>
<span class="prismident">pow</span>(<span class="prismnum">2</span>, <span class="prismnum">8</span>)<br/>
<span class="prismident">pow</span>(<span class="prismnum">9.0</span>, <span class="prismnum">0.5</span>)<br/>
<span class="prismident">mod</span>(<span class="prismnum">1977</span>, <span class="prismnum">100</span>)<br/>
<span class="prismident">log</span>(<span class="prismnum">123</span>, <span class="prismnum">2.71828183</span>)<br/>
</div></div>
</div>
<p class='vspace'>For compatability with older versions of PRISM, all functions can also be expressed via the <code><strong>func</strong></code> keyword, e.g. <code>func(floor, 13.5)</code>.
</p>
<p class='vspace'><strong>Use of Expressions</strong>
</p>
<p class='vspace'>Expressions can be used in a wide range of places in a PRISM language description, e.g.:
</p>
<div class='vspace'></div><ul><li>constant definitions
</li><li>lower/upper bounds and initial values for variables
</li><li>guards
</li><li>probabilities/rates
</li><li>updates
</li></ul><p class='vspace'>This allows, for example, the probability in a command to be dependent on the current state:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] (<span class="prismident">x</span>&gt;=<span class="prismnum">1</span> &amp; <span class="prismident">x</span>&lt;=<span class="prismnum">10</span>) -&gt; <span class="prismident">x</span>/<span class="prismnum">10</span> : (<span class="prismident">x</span>'=<span class="prismkeyword">max</span>(<span class="prismnum">1</span>,<span class="prismident">x</span>-<span class="prismnum">1</span>)) + <span class="prismnum">1</span>-<span class="prismident">x</span>/<span class="prismnum">10</span> : (<span class="prismident">x</span>'=<span class="prismkeyword">min</span>(<span class="prismnum">10</span>,<span class="prismident">x</span>+<span class="prismnum">1</span>))<br/>
</div></div>
</div>
<hr />
<h1>Synchronisation</h1>
<p>Another feature of PRISM introduced in Example 2 is <em>synchronisation</em>.
In the style of many process algebras, we allow commands to be labelled with <em>actions</em>.
These are placed inside the square brackets which mark the start of the command,
for example <code>serve</code> in this command from <a class='wikilink' href='Example2.html'>Example 2</a>:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[<span class="prismident">serve</span>] <span class="prismident">q</span>&gt;<span class="prismnum">0</span> -&gt; <span class="prismident">lambda</span>:(<span class="prismident">q</span>'=<span class="prismident">q</span>-<span class="prismnum">1</span>);<br/>
</div></div>
</div>
<p class='vspace'>These actions can be used to force two or more modules to make transitions simultaneously
(i.e. to <em>synchronise</em>).
For example, in state <code>(3,0)</code> (i.e.  <code>q=3</code> and <code>s=0</code>),
the composed model can move to state <code>(2,1)</code>,
synchronising over the <code>serve</code> action.
The rate of this transition is equal to the product of the two individual rates
(in this case, <code>lambda * 1 = lambda</code>).
The product of two rates does not always meaningfully represent the rate of a synchronised transition.
A common technique, as seen here, is to make one action <em>passive</em>, with rate 1 and one action <em>active</em>,
which actually defines the rate for the synchronised transition.
By default, all modules are combined using the standard CSP parallel composition
(i.e. modules synchronise over all their common actions).
</p><hr />
<h1>Process Algebra Operators</h1>
<p>To make the concept of synchronisation described above more powerful,
PRISM allows you to define precisely the way in which the set of modules are composed in parallel.
This is specified using the <code><strong>system</strong> ... <strong>endsystem</strong></code> construct,
placed at the end of the model description, which should contain a process-algebraic expression.
This expression should feature each module exactly once, and can use the following (CSP-based) operators:
</p>
<div class='vspace'></div><ul><li><code>M1 || M2</code> : alphabetised parallel composition of modules <code>M1</code> and <code>M2</code> (synchronising on only actions appearing in both <code>M1</code> and <code>M2</code>)
<div class='vspace'></div></li><li><code>M1 ||| M2</code> : asynchronous parallel composition of <code>M1</code> and <code>M2</code> (fully interleaved, no synchronisation)
<div class='vspace'></div></li><li><code>M1 |[a,b,...]| M2</code> : restricted parallel composition of modules <code>M1</code> and <code>M2</code> (synchronising only on actions from the set {<code>a</code>, <code>b</code>,...})
<div class='vspace'></div></li><li><code>M / {a,b,...</code>} : hiding of actions {<code>a</code>, <code>b</code>, ...} in module <code>M</code>
<div class='vspace'></div></li><li><code>M {a&lt;-b,c&lt;-d,...</code>} : renaming of actions <code>a</code> to <code>b</code>, <code>c</code> to <code>d</code>, etc. in module <code>M</code>.
</li></ul><p class='vspace'>The first two types of parallel composition (<code>||</code> and <code>|||</code>) are associative and can be applied to more than two modules at once.
When evaluating the expression, the hiding and renaming operators bind more tightly than the three parallel composition operators.
No other rules of precedence are defined and parentheses should be used to specify the order in which modules are composed.
</p>
<p class='vspace'>Some examples of expressions which could be included in the <code><strong>system</strong> ... <strong>endsystem</strong></code> construct are as follows:
</p>
<div class='vspace'></div><ul><li><code>(station1 ||| station2 ||| station3) |[serve]| server</code>
</li><li><code>((P1 |[a]| P2) / {a}) || Q</code>
</li><li><code>((P1 |[a]| P2) {a&lt;-b}) |[b]| Q</code>
</li></ul><p class='vspace'>When no parallel composition is specified by the user,
PRISM implicitly assumes an expression of the form <code>M1 || M2 || ...</code> containing all of the modules in the model.
For a more formal definition of the process algebra operators described above, check the semantics of the PRISM language, available from the "<a class='urllink' href='http://www.prismmodelchecker.org/doc/'>Documentation</a>" section of the PRISM web site.
</p>
<p class='vspace'>PRISM is also able to <a class='wikilink' href='../RunningPRISM/SupportForPEPAModels.html'>import</a> model descriptions written in (a subset of) the stochastic process algebra <a class='urllink' href='http://www.dcs.ed.ac.uk/pepa/'>PEPA</a> [<a class='wikilink' href='../Main/References.html#Hil96'>Hil96</a>].
</p><hr />
<h1>Global Variables</h1>
<p>In addition to the local variables belonging to each module, a PRISM model can also include <em>global variables</em>,
which can be written to, as well as read, by all modules.
Like local variables, these can be integers or Booleans.
Global variables are declared in identical fashion to a module's local variables,
except that the declaration must not be inside the definition of any module.
Some example declarations are as follows:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">global</span> <span class="prismident">g</span> : [<span class="prismnum">1</span>..<span class="prismnum">10</span>];<br/>
<span class="prismkeyword">global</span> <span class="prismident">b</span> : <span class="prismkeyword">bool</span> <span class="prismkeyword">init</span> <span class="prismkeyword">true</span>;<br/>
</div></div>
</div>
<p class='vspace'>A global variable can be modified by any module and provides another way for modules to interact.
An important restriction on the use of global variables is the fact that commands which synchronise with other modules
(i.e. those with an action label attached; see the section "<a class='wikilink' href='Synchronisation.html'>Synchronisation</a>") cannot modify global variables.
PRISM will detect this and report an error.
</p><hr />
<h1>Formulas And Labels</h1>
<p>PRISM models can include <em>formulas</em> which are used to avoid duplication of code.
A formula comprises a name (an identifier) and an <a class='wikilink' href='Expressions.html'>expression</a>.
The formula name can then be used as shorthand for the expression anywhere an expression might usually be accepted.
A formula is defined as follows:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">formula</span> <span class="prismident">lfree</span> = <span class="prismident">p2</span>=<span class="prismnum">0</span>..<span class="prismnum">4</span>,<span class="prismnum">6</span>,<span class="prismnum">10</span>;<br/>
</div></div>
</div>
<p class='vspace'>It can then be used anywhere within that file, as for example in this command:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">p1</span>=<span class="prismnum">2</span> &amp; <span class="prismident">lfree</span> -&gt; (<span class="prismident">p1</span>'=<span class="prismnum">4</span>);<br/>
</div></div>
</div>
<p class='vspace'>The effect is exactly as if the following had been typed:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism">[] <span class="prismident">p1</span>=<span class="prismnum">2</span> &amp; (<span class="prismident">p2</span>=<span class="prismnum">0</span>..<span class="prismnum">4</span>,<span class="prismnum">6</span>,<span class="prismnum">10</span>) -&gt; (<span class="prismident">p1</span>'=<span class="prismnum">4</span>);<br/>
</div></div>
</div>
<p class='vspace'>Formulas defined in a model can also be used when specifying its properties.
</p>
<div class='vspace'></div><h3>Formulas and renaming</h3>
<p>During parsing of the model, expansion of formulas is done before module renaming so, if a module which uses formulas is renamed to another module, it is the contents of the formula which will be renamed, not the formula itself.
</p>
<div class='vspace'></div><h3>Labels</h3>
<p>PRISM models can also contain <em>labels</em>. These are are a way of identifying sets of states that are of particular interest. Labels can only be used when specifying <a class='wikilink' href='../PropertySpecification/Introduction.html'>properties</a> but, for convenience, can be defined in model files as well as property files. 
</p>
<p class='vspace'>Labels differ from formulas in two other ways: firstly, they must be of Boolean type;
secondly, they are written using quotation marks (<code>"..."</code>), as illustrated in the following example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">label</span> "<span class="prismident">safe</span>" = <span class="prismident">temp</span>&lt;=<span class="prismnum">100</span> | <span class="prismident">alarm</span>=<span class="prismkeyword">true</span>;<br/>
<span class="prismkeyword">label</span> "<span class="prismident">fail</span>" = <span class="prismident">temp</span>&gt;<span class="prismnum">100</span> &amp; <span class="prismident">alarm</span>=<span class="prismkeyword">false</span>;<br/>
</div></div>
</div>
<hr />
<h1>PRISM Language Files</h1>
<p>Files containing model descriptions written in the PRISM language
can contain any amount of white space (spaces, tabs, new lines, etc.),
all of which is ignored when the file is parsed by the tool.
Comments can also be used included in files in the style of the C programming language,
by preceding them with the characters <code>//</code>.
This is illustrated by the PRISM language examples from earlier in this section.
By convention, PRISM model files which describe MDPs, DTMCs and CTMCs are given the extensions 
<code>.nm</code>, <code>.pm</code> and <code>.sm</code>, respectively.
</p><hr />
<h1>Costs And Rewards </h1>
<p>PRISM now includes support for the specification and analysis of
properties based on <em>costs</em> and <em>rewards</em>.
This means that PRISM can be used to reason,
not just about the probability that a model behaves in a certain fashion,
but about a wider range of quantitative measures relating to model behaviour.
For example, PRISM can be used to compute properties such as
"expected time", "expected number of lost messages" or "expected power consumption".
The implementation of cost- and reward-based techniques in the tool is only partially completed and is still ongoing.
If you have questions, comments or feature-requests relating to this functionality,
please feel free to contact the PRISM team about this.
</p>
<p class='vspace'>The basic idea is that probabilistic models (of all three types) developed in PRISM
can be augmented with costs or rewards: real values associated with certain states or transitions of the model.
In fact, since there is no practical distinction between costs and rewards
(except that costs are generally perceived to be "bad" and rewards to be "good"),
PRISM only supports rewards.
The user is, however, free to interpret the values however they choose.
</p>
<p class='vspace'>In this section, we describe how models described in the PRISM language
can be augmented with rewards.
Later, we will discuss how to express properties that relate to these rewards.
Rewards are associated with models using <code><strong>rewards</strong> ... <strong>endrewards</strong></code> constructs,
which can appear anywhere in a model file except within a module definition.
These constructs contains one or more <em>reward items</em>.
Consider the following simple example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>This assigns a reward of 1 to every state of the model.
It comprises a single reward item, the left part of which (<code><strong>true</strong></code>) is a guard
and the right part of which (<code>1</code>) is a reward.
States of the model which satisfy the predicate in the guard are assigned the corresponding reward.
More generally, state rewards can be specified using multiple reward items,
each of the form <code>guard : reward;</code>,
where <code>guard</code>is a predicate (over all the variables of the model)
and <code>reward</code> is an expression (containing any variables, constants, etc. from the model).
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span>=<span class="prismnum">0</span> : <span class="prismnum">100</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span>&gt;<span class="prismnum">0</span> &amp; <span class="prismident">x</span>&lt;<span class="prismnum">10</span> : <span class="prismnum">2</span>*<span class="prismident">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismident">x</span>=<span class="prismnum">10</span> : <span class="prismnum">100</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>assigns a reward of 100 to states satisfying <code>x=0</code> or <code>x=10</code>
and a reward of <code>2*x</code> to states satisfying <code>x&gt;0 &amp; x&lt;10</code>.
Note that a single reward item can assign different rewards to different states,
depending on the values of model variables in each one.
Any states which do not satisfy the guard of any reward item will have no reward assigned to them.
For states which satisfy multiple guards, the reward assigned to the state
is the sum of the rewards for all the corresponding reward items.
</p>
<p class='vspace'>Rewards can also be assigned to transitions of a model.
These are specified in a similar fashion to state rewards,
within the <code><strong>rewards</strong> ... <strong>endrewards</strong></code> construct.
Reward items describing transition rewards are of the form <code>[action] guard : reward;</code>,
the interpretation being that transitions from states which satisfy the guard <code>guard</code>
and are labelled with the action <code>action</code> acquire the reward <code>reward</code>.
For example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;[] <span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">a</span>] <span class="prismkeyword">true</span> : <span class="prismident">x</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">b</span>] <span class="prismkeyword">true</span> : <span class="prismnum">2</span>*<span class="prismident">x</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<p class='vspace'>assigns a reward of 1 to all transitions in the model with no action label,
and rewards of <code>x</code> and <code>2*x</code> to all transitions labelled with actions <code>a</code> and <code>b</code>, respectively.
</p>
<p class='vspace'>As is the case for states, multiple reward items can specify rewards for a single transition,
in which case the resulting reward is the sum of all the individual rewards.
A model description can specify rewards for both states and transitions.
These are all placed together in a single <code><strong>rewards</strong>...<strong>endrewards</strong></code> construct.
</p>
<p class='vspace'>A PRISM model can have multiple reward structures. Optionally, these can be given labels such as in the following example:
</p>
<div class='vspace'></div><div class='sourceblock'>
 <div class='sourceblocktext'><div class="prism"><span class="prismkeyword">rewards</span> "<span class="prismident">total_time</span>"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
<br/>
<span class="prismkeyword">rewards</span> "<span class="prismident">num_failures</span>"<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[<span class="prismident">fail</span>] <span class="prismkeyword">true</span> : <span class="prismnum">1</span>;<br/>
<span class="prismkeyword">endrewards</span><br/>
</div></div>
</div>
<div class='vspace'></div>
</div>


<!--PageFooterFmt-->
  <div id='prism-man-footer'>
  </div>
<!--/PageFooterFmt-->


<!-- ============================================================================= -->

</div> <!-- id="prism-mainbox" -->

</div> <!-- id="layout-main" -->
</div> <!-- id="layout-maincontainer" -->

<div id="layout-leftcol">
<div id="prism-navbar2">

<h3><a class='wikilink' href='../Main/Welcome.html'>PRISM Manual</a></h3>
<p><strong><a class='wikilink' href='Introduction.html'>The PRISM Language</a></strong>
</p><ul><li><a class='wikilink' href='Introduction.html'>Introduction</a>
</li><li><a class='wikilink' href='Example1.html'>Example 1</a>
</li><li><a class='wikilink' href='ModelType.html'>Model Type</a>
</li><li><a class='wikilink' href='ModulesAndVariables.html'>Modules And Variables</a>
</li><li><a class='wikilink' href='InitialStates.html'>Initial States</a>
</li><li><a class='wikilink' href='Commands.html'>Commands</a>
</li><li><a class='wikilink' href='ParallelComposition.html'>Parallel Composition</a>
</li><li><a class='wikilink' href='LocalNondeterminism.html'>Local Nondeterminism</a>
</li><li><a class='wikilink' href='ModuleRenaming.html'>Module Renaming</a>
</li><li><a class='wikilink' href='Example2.html'>Example 2</a>
</li><li><a class='wikilink' href='Constants.html'>Constants</a>
</li><li><a class='wikilink' href='Expressions.html'>Expressions</a>
</li><li><a class='wikilink' href='Synchronisation.html'>Synchronisation</a>
</li><li><a class='wikilink' href='ProcessAlgebraOperators.html'>Process Algebra Operators</a>
</li><li><a class='wikilink' href='GlobalVariables.html'>Global Variables</a>
</li><li><a class='wikilink' href='FormulasAndLabels.html'>Formulas And Labels</a>
</li><li><a class='wikilink' href='PRISMLanguageFiles.html'>PRISM Language Files</a>
</li><li><a class='wikilink' href='CostsAndRewards.html'>Costs And Rewards</a>
</li></ul><p>[ <a class='selflink' href='AllOnOnePage.html'>View all</a> ]
</p>


</div>  <!-- id="prism-navbar2" -->
</div> <!-- id="layout-leftcol" -->

</body>
</html>
